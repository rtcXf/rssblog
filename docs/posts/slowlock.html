<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Slowlock | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/limplock/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Slowlock</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p>Every once in awhile, you hear a story like “there was a case of a 1-Gbps NIC card on a machine that suddenly was transmitting only at 1 Kbps, which then caused a chain reaction upstream in such a way that the performance of the entire workload of a 100-node cluster was crawling at a snail&#39;s pace, effectively making the system unavailable for all practical purposes”. The stories are interesting and the postmortems are fun to read, but it&#39;s not really clear how vulnerable systems are to this kind of failure or how prevalent these failures are.</p> <p>The situation reminds me of distributed systems failures before <a href="https://aphyr.com/tags/jepsen">Jepsen</a>. There are lots of anecdotal horror stories, but a common response to those is “works for me”, even when talking about systems that are now known to be fantastically broken. A handful of companies that are really serious about correctness have good tests and metrics, but they mostly don&#39;t talk about them publicly, and the general public has no easy way of figuring out if the systems they&#39;re running are sound.</p>  <p>Thanh Do et al. have tried to look at this systematically -- <a href="http://ucare.cs.uchicago.edu/pdf/socc13-limplock.pdf">what&#39;s the effect of hardware that&#39;s been crippled but not killed</a>, and <a href="http://ucare.cs.uchicago.edu/pdf/socc14-cbs.pdf">how often does this happen in practice</a>? It turns out that a lot of commonly used systems aren&#39;t robust against against “limping” hardware, but that the incidence of these types of failures are rare (at least until you have unreasonably large scale).</p> <p>The effect of a single slow node can be <a href="http://pages.cs.wisc.edu/~thanhdo/pdf/talk-socc-limplock.pdf">quite dramatic</a>:</p> <p><img src="https://danluu.com/images/limpware/fb_slow_nic.png" alt="The effect of a single slow NIC on an entire cluster" width="484" height="328"/></p> <p>The job completion rate slowed down from 172 jobs per hour to 1 job per hour, effectively killing the entire cluster. Facebook has mechanisms to deal with dead machines, but they apparently didn&#39;t have any way to deal with slow machines at the time.</p> <p>When Do et al. looked at widely used open source software (HDFS, Hadoop, ZooKeeper, Cassandra, and HBase), they found similar problems.</p> <p><img src="https://danluu.com/images/limpware/limpware.png" width="617" height="362"/></p> <p>Each subgraph is a different failure condition. F is HDFS, H is Hadoop, Z is Zookeeper, C is Cassandra, and B is HBase. The leftmost (white) bar is the baseline no-failure case. Going to the right, the next is a crash, and the subsequent bars are results for a single degraded but not crashed hardware (further right means slower). In most (but not all) cases, having degraded hardware affected performance a lot more than having failed hardware. Note that these graphs are all log scale; going up one increment is a 10x difference in performance!</p> <p>Curiously, a failed disk can cause some operations to speed up. That&#39;s because there are operations that have less replication overhead if a replica fails. It seems a bit weird to me that there isn&#39;t more overhead, because the system has to both find a replacement replica and replicate data, but what do I know?</p> <p>Anyway, why is a slow node so much worse than a dead node? The authors define three failure modes and explain what causes each one. There&#39;s operation limplock, when an operation is slow because some subpart of the operation is slow (e.g., a disk read is slow because the disk is degraded), node limplock, when a node is slow even for seemingly unrelated operations (e.g, a read from RAM is slow because a disk is degraded), and cluster limplock, where the entire cluster is slow (e.g., a single degraded disk makes an entire 1000 machine cluster slow).</p> <p>How do these happen?</p> <h4 id="operation-limplock">Operation Limplock</h4> <p>This one is the simplest. If you try to read from disk, and your disk is slow, your disk read will be slow. In the real world, we&#39;ll see this when operations have a single point of failure, and when monitoring is designed to handle total failure and not degraded performance. For example, an HBase access to a region goes through the server responsible for that region. The data is replicated on HDFS, but this doesn&#39;t help you if the node that owns the data is limping. Speaking of HDFS, it has a timeout is 60s and reads are in 64K chunks, which means your reads can slow down to almost 1K/s before HDFS will fail over to a healthy node.</p> <h4 id="node-limplock">Node Limplock</h4> <p>How can it be the case that (for example) a slow disk causes memory reads to be slow? Looking at HDFS again, it uses a thread pool. If every thread is busy very slowly completing a disk read, memory reads will block until a thread gets free.</p> <p>This isn&#39;t only an issue when using limited thread pools or other bounded abstractions -- the reality is that machines have finite resources, and unbounded abstractions will run into machine limits if they aren&#39;t carefully designed to avoid the possibility. For example, Zookeeper keeps queue of operations, and a slow follower can cause the leader&#39;s queue to exhaust physical memory.</p> <h4 id="cluster-limplock">Cluster Limplock</h4> <p>An entire cluster can easily become unhealthy if it relies on a single primary and the primary is limping. Cascading failures can also cause this -- the first graph, where a cluster goes from completing 172 jobs an hour to 1 job an hour is actually a Facebook workload on Hadoop. The thing that&#39;s surprising to me here is that Hadoop is supposed to be tail tolerant -- individual slow tasks aren&#39;t supposed to have a large impact on the completion of the entire job. So what happened? Unhealthy nodes infect healthy nodes and eventually lock up the whole cluster.</p> <p><img src="https://danluu.com/images/limpware/cascade.png" alt="An unhealthy node infects an entire cluster" width="211" height="147"/></p> <p>Hadoop&#39;s tail tolerance comes from kicking off speculative computation when results are coming in slowly. In particular, when stragglers come in unusually slowly compared to other results. This works fine when a reduce node is limping (subgraph H2), but when a <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf">map node</a> limps (subgraph H1), it can slow down all reducers in the same job, which defeats Hadoop&#39;s tail-tolerance mechanisms.</p> <p><img src="https://danluu.com/images/limpware/hadoop_deadlock.png" alt="A single bad map node effectively deadlocks hadoop" width="176" height="62"/></p> <p>To see why, we have to look at <a href="https://www.usenix.org/legacy/event/osdi08/tech/full_papers/zaharia/zaharia_html/index.html">Hadoop&#39;s speculation algorithm</a>. Each job has a progress score which is a number between 0 and 1 (inclusive). For a map, the score is the fraction of input data read. For a reduce, each of three phases (copying data from mappers, sorting, and reducing) gets 1/3 of the score. A speculative job will get run if a task has run for at least one minute and has a progress score that&#39;s less than the average for its category minus 0.2.</p> <p>In case H2, the NIC is limping, so the map phase completes normally since results end up written to local disk. But when reduce nodes try to fetch data from the limping map node, they all stall, pulling down the average score for the category, which prevents speculative jobs from being run. Looking at the big picture, each Hadoop node has a limited number of map and reduce tasks. If those fill up with limping tasks, the entire node will lock up. Since Hadoop isn&#39;t designed to avoid cascading failures, this eventually causes the entire cluster to lock up.</p> <p>One thing I find interesting is that this exact cause of failures was <a href="http://research.google.com/archive/mapreduce.html">described in the original MapReduce paper</a>, published in 2004. They even explicitly called out slow disk and network as causes of stragglers, which motivated their speculative execution algorithm. However, they didn&#39;t provide the details of the algorithm. The open source clone of MapReduce, Hadoop, attempted to avoid the same problem. Hadoop was initially released in 2008. Five years later, when the paper we&#39;re reading was published, its built-in mechanism for straggler detection not only failed to prevent multiple types of stragglers, it also failed to prevent stragglers from effectively deadlocking the entire cluster.</p> <h3 id="conclusion">Conclusion</h3> <p>I&#39;m not going to go into details of how each system fared under testing. That&#39;s detailed quite nicely in the paper, which I recommend reading the paper if you&#39;re curious. To summarize, Cassandra does quite well, whereas HDFS, Hadoop, and HBase don&#39;t.</p> <p>Cassandra seems to do well for two reasons. First, <a href="https://issues.apache.org/jira/browse/CASSANDRA-488">this patch from 2009</a> prevents queue overflows from infecting healthy nodes, which prevents a major failure mode that causes cluster-wide failures in other systems. Second, the architecture used (<a href="http://www.eecs.harvard.edu/~mdw/proj/seda/">SEDA</a>) decouples different types of operations, which lets good operations continue to execute even when some operations are limping.</p> <p>My big questions after reading this paper are, how often do these kinds of failures happen, how, and shouldn&#39;t reasonable metrics/reporting catch this sort of thing anyway?</p> <p>For the answer to the first question, many of the same authors also have a paper where they looked at <a href="http://ucare.cs.uchicago.edu/pdf/socc14-cbs.pdf">3000 failures in Cassandra, Flume, HDFS, and ZooKeeper</a> and determined which failures were hardware related and what the hardware failure was.</p> <p><img src="https://danluu.com/images/limpware/hardware_failure_causes.png" width="147" height="104"/></p> <p>14 cases of degraded performance vs. 410 other hardware failures. In their sample, that&#39;s 3% of failures; rare, but not so rare that we can ignore the issue.</p> <p>If we can&#39;t ignore these kinds of errors, how can we catch them before they go into production? The paper uses the <a href="http://www.emulab.net/">Emulab testbed</a>, which is really cool. Unfortunately, the Emulab page reads “Emulab is a public facility, available without charge to most researchers worldwide. If you are unsure if you qualify for use, please see our policies document, or ask us. If you think you qualify, you can apply to start a new project.”. That&#39;s understandable, but that means it&#39;s probably not a great solution for most of us.</p> <p>The vast majority of limping hardware is due to network or disk slowness. Why couldn&#39;t a modified version of Jepsen, or something like it, simulate disk or network slowness? A naive implementation wouldn&#39;t get anywhere near the precision of Emulab, but since we&#39;re talking about order of magnitude slowdowns, having 10% (or even 2x) variance should be ok for testing the robustness of systems against degraded hardware. There are a number of ways you could imagine that working. For example, to simulate a slow network on linux, you could try throttling <a href="http://linux-ip.net/articles/Traffic-Control-HOWTO/">via qdisc</a>, <a href="https://github.com/majek/fluxcapacitor">hooking syscalls via ptrace</a>, etc. For a slow CPU, you can rate-limit via cgroups and cpu.shares, or just map the process to UC memory (or maybe WT or WC if that&#39;s a bit too slow), and so on and so forth for disk and other failure modes.</p> <p>That leaves my last question, shouldn&#39;t systems already catch these sorts of failures even if they&#39;re not concerned about them in particular? As we saw above, systems with cripplingly slow hardware are rare enough that we can just treat them as dead without significantly impacting our total compute resources. And systems with crippled hardware can be detected pretty straightforwardly. Moreover, multi-tenant systems have to do <a href="https://danluu.com/new-cpu-features/#partitioning">continuous monitoring of their own performance to get good utilization</a> anyway.</p> <p>So why should we care about designing systems that are robust against limping hardware? One part of the answer is defense in depth. Of course we should have monitoring, but we should also have systems that are robust when our monitoring fails, as it inevitably will. Another part of the answer is that by making systems more tolerant to limping hardware, we&#39;ll also make them more tolerant to interference from other workloads in a multi-tenant environment. That last bit is a somewhat speculative empirical question -- it&#39;s possible that it&#39;s more efficient to design systems that aren&#39;t particularly robust against interference from competing work on the same machine, while using <a href="https://danluu.com/intel-cat/">better partitioning</a> to avoid interference.</p>  </div></div>
        </section>
    </article>
</main>
</body>
</html>
