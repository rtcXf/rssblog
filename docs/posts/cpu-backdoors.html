<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CPU backdoors | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/cpu-backdoors/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>CPU backdoors</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p>It&#39;s generally accepted that any piece of software could be compromised with a backdoor. Prominent examples include the <a href="http://en.wikipedia.org/wiki/Sony_BMG_copy_protection_rootkit_scandal">Sony/BMG installer</a>, which had a backdoor built-in to allow Sony to keep users from copying the CD, which also allowed malicious third-parties to take over any machine with the software installed; the <a href="http://redmine.replicant.us/projects/replicant/wiki/SamsungGalaxyBackdoor">Samsung Galaxy</a>, which has a backdoor that allowed the modem to access the device&#39;s filesystem, which also allows anyone running <a href="https://www.youtube.com/watch?v=RXqQioV_bpo">a fake base station to access files on the device</a>; <a href="http://www.cypherspace.org/adam/hacks/lotus-nsa-key.html">Lotus Notes</a>, which had a backdoor which allowed encryption to be defeated; and <a href="https://forums.lenovo.com/t5/Lenovo-P-Y-and-Z-series/Lenovo-Pre-instaling-adware-spam-Superfish-powerd-by/td-p/1726839">Lenovo laptops</a>, which pushed all web traffic through a proxy (including HTTPS, via a trusted root certificate) in order to push ads, which allowed anyone with the correct key (which was distributed on every laptop) to intercept HTTPS traffic.</p> <p>Despite sightings of backdoors in <a href="http://www.cl.cam.ac.uk/~sps32/sec_news.html#Assurance">FPGAs</a> and <a href="https://github.com/elvanderb/TCP-32764">networking gear</a>, whenever someone brings up the possibility of CPU backdoors, it&#39;s still common for people to claim that it&#39;s <a href="https://news.ycombinator.com/item?id=6147767">impossible</a>. I&#39;m not going to claim that CPU backdoors exist, but I will claim that the implementation is easy, if you&#39;ve got the right access.</p>  <p>Let&#39;s say you wanted to make a backdoor. How would you do it? There are three parts to this: what could a backdoored CPU do, how could the backdoor be accessed, and what kind of compromise would be required to install the backdoor?</p> <p>Starting with the first item, what does the backdoor do? There are a lot of possibilities. The simplest is to allow privilege escalation: make the CPU to <a href="http://en.wikipedia.org/wiki/Protection_ring">transition from ring3 to ring0 or SMM</a>, giving the running process kernel-level privileges. Since it&#39;s the CPU that&#39;s doing it, this can punch through both hardware and software virtualization. There are a lot of subtler or more invasive things you could do, but privilege escalation is both simple enough and powerful enough that I&#39;m not going to discuss the other options.</p> <p>Now that you know what you want the backdoor to do, how should it get triggered? Ideally, it will be something that no one will run across by accident, or even by brute force, while looking for backdoors. Even with that limitation, the state space of possible triggers is huge.</p> <p>Let&#39;s look at a particular instruction, <code>fyl2x</code>. Under normal operation, it takes two floating point registers as input, giving you <code>2*80=160</code> bits to hide a trigger in. If you trigger the backdoor off of a specific pair of values, that&#39;s probably safe against random discovery. If you&#39;re really worried about someone stumbling across the backdoor by accident, or brute forcing a suspected backdoor, you can check more than the two normal input registers (after all, you&#39;ve got control of the CPU).</p> <p>This trigger is nice and simple, but the downside is that hitting the trigger probably requires executing native code since you&#39;re unlikely to get chrome or Firefox to emit an <code>fyl2x</code> instruction. You could try to work around that by triggering off an instruction you can easily get a JavaScript engine to emit (like an <code>fadd</code>). The problem with that is that if you patch an add instruction and add some checks to it, it will become noticeably slower (although, if you can edit the hardware, you should be able to do it with no overhead). It might be possible to create something hard to detect that&#39;s triggerable through JavaScript by patching a <a href="http://www.csc.depauw.edu/~bhoward/asmtut/asmtut7.html">rep string</a> instruction and doing some stuff to set up the appropriate “key” followed by a block copy, or maybe <code>idiv</code>. Alternately, if you&#39;ve managed to get a copy of the design, you can probably figure out a way to use debug logic triggers or performance counters to set off a backdoor when some arbitrary JavaScript gets run.</p> <p>Alright, now you&#39;ve got a backdoor. How do you insert the backdoor? In software, you&#39;d either edit the source or the <a href="https://danluu.com/edit-binary/">binary</a>. In hardware, if you have access to the source, you can edit it as easily as you can in software. The hardware equivalent of recompiling the source, creating physical chips, has tremendously high fixed costs; if you&#39;re trying to get your changes into the source, you&#39;ll want to either compromise the design and insert your edits before everything is sent off to get manufactured, or compromise the manufacturing process and sneak in your edits at the last second.</p> <p>If that sounds too hard, you could try compromising the patch mechanism. Most modern CPUs come with a built-in patch mechanism to allow bug fixes after the fact. It&#39;s likely that the CPU you&#39;re using has been patched, possibly from day one, and possibly as part of a firmware update. The details of the patch mechanism for your CPU are a closely guarded secret. It&#39;s likely that the CPU has a public key etched into it, and that it will only accept a patch that&#39;s been signed by the right private key.</p> <p>Is this actually happening? I have no idea. Could it be happening? Absolutely. What are the odds? Well, the primary challenge is non-technical, so I&#39;m not the right person to ask about that. If I had to guess, I&#39;d say no, if for no other reason than the <a href="https://github.com/elvanderb/TCP-32764">ease of subverting other equipment</a>.</p> <p><small> I haven&#39;t discussed how to make a backdoor that&#39;s hard to detect even if someone has access to software you&#39;ve used to trigger a backdoor. That&#39;s harder, but it should be possible once chips start coming with built-in <a href="http://en.wikipedia.org/wiki/Trusted_Platform_Module">TPMs</a>.</small></p> <p><strong>If you liked this post, you&#39;ll probably enjoy <a href="https://danluu.com/cpu-bugs/">this post on CPU bugs</a> and might be interested in <a href="https://danluu.com/new-cpu-features/">this post about new CPU features over the past 35 years</a>.</strong></p> <h4 id="updates">Updates</h4> <p>See <a href="https://twitter.com/danluu/status/562962211782815746">this twitter thread</a> for much more discussion, some of which is summarized below.</p> <p>I&#39;m not going to provide individual attributions because there are too many comments, but here&#39;s a summary of comments from @hackerfantastic, Arrigo Triulzi, David Kanter, @solardiz, @4Dgifts, Alfredo Ortega, Marsh Ray, and Russ Cox. Mistakes are my own, of course.</p> <p><a href="http://www.realworldtech.com/forum/?threadid=35566&amp;curpostid=35566">AMD&#39;s K7 and K8 had their microcode patch mechanisms compromised</a>, allowing for the sort of attacks mentioned in this post. Turns out, AMD didn&#39;t encrypt updates or validate them with a checksum, which lets you easily modify updates until you get one that does what you want.</p> <p><a href="http://es.slideshare.net/ortegaalfredo/deep-submicronbackdoorsortegasyscan2014slides">Here&#39;s an example of a backdoor that was created for demonstration purposes</a>, by Alfredo Ortega.</p> <p>For folks without a hardware background, <a href="http://media.ccc.de/browse/congress/2013/30C3_-_5443_-_en_-_saal_g_-_201312281830_-_introduction_to_processor_design_-_byterazor.html#video">this talk on how to implement a CPU in VHDL is nice, and it has a section on how to implement a backdoor</a>.</p> <p>Is it possible to backdoor RDRAND by providing bad random results? Yes. I mentioned that in my first draft of this post, but I got rid of it since my impression was that people don&#39;t trust RDRAND and mix the results other sources of entropy. That doesn&#39;t make a backdoor useless, but it significantly reduces the value.</p> <p>Would it be possible to store and dump AES-NI keys? It&#39;s probably infeasible to sneak flash memory onto a chip without anyone noticing, but modern chips have logic analyzer facilities that let you store and dump data. However, access to those is through some secret mechanism and it&#39;s not clear how you&#39;d even get access to binaries that would let you reverse engineer their operation. That&#39;s in stark contrast to the K8 reverse engineering, which was possible because microcode patches get included in firmware updates.</p> <p>It would be possible to check instruction prefixes for the trigger. x86 lets you put redundant (and contradictory) instruction prefixes on instructions. Which prefixes get used are well defined, so you can add as many prefixes as you want without causing problems (up to the prefix length limit). The issues with this are that it&#39;s probably hard to do without sacrificing performance with a microcode patch, the limited number of prefixes and the length limit mean that your effective key size is relatively small if you don&#39;t track state across multiple instructions, and that you can only generate the trigger with native code.</p> <p>As far as anyone knows, this is all speculative, and no one has seen an actual CPU backdoor being used in the wild.</p> <h4 id="acknowledgments">Acknowledgments</h4> <p>Thanks to Leah Hanson for extensive comments, to Aleksey Shipilev and Joe Wilder for suggestions/corrections, and to the many participants in the twitter discussion linked to above. Also, thanks to Markus Siemens for noticing that a bug in some RSS readers was causing problems, and for providing the workaround. That&#39;s not really specific to this post, but it happened to come up here. </p>  </div></div>
        </section>
    </article>
</main>
</body>
</html>
