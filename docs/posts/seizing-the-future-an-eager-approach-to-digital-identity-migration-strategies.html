<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Seizing the Future: An Eager Approach to Digital Identity Migration Strategies | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://robertleggett.blog/2024/10/17/seizing-the-future-an-eager-approach-to-digital-identity-migration-strategies/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Seizing the Future: An Eager Approach to Digital Identity Migration Strategies</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div>
		
<p>In today’s digital age, managing digital identities efficiently and securely has become a cornerstone for any online platform. Among the various strategies to upgrade or shift digital identity management systems, two approaches stand out: Eager Migration and Lazy Migration, each with its unique advantages and challenges. In this exploration, we delve into the nuances, particularly focusing on the proactive stance of Eager Migration.</p>



<h2>Before you start</h2>



<p>About this post:</p>



<ul>
<li>5 – 10 min average reading time</li>



<li>Suitable for intermediate through to advanced</li>
</ul>



<p>What you will gain reading this post:</p>



<ul>
<li>An overview of the migration strategies</li>



<li>A guide on choosing the best approach to support your solution</li>
</ul>



<p>What you can do to help support:</p>



<ul>
<li><strong>Like, comment and share this article</strong></li>



<li><strong>Follow this blog</strong> to receive notifications of new postings</li>
</ul>



<p>Now, let’s get started.</p>



<h2>Migration Strategies</h2>



<p>When transitioning to a new identity platform or system, choosing the right migration strategy is essential to ensure minimal disruption and optimal user experience. Two primary strategies are <strong>Eager Migration</strong> and <strong>Lazy Migration</strong>. Each has its strengths and weaknesses, and the choice depends on the system’s goals, user base, and operational constraints.</p>



<h3>Eager Migration</h3>



<p>Eager Migration represents a proactive and decisive approach, transferring all user accounts and associated data to the new system in a single, large-scale migration before any user interaction is required.</p>



<p><strong>Advantages:</strong></p>



<ul>
<li><strong>Immediate Consistency:</strong> All users are migrated simultaneously, ensuring system-wide consistency and eliminating version discrepancies.</li>



<li><strong>Enhanced User Experience:</strong> Users seamlessly access the new system without needing to take any action, such as re-registering or re-authenticating.</li>



<li><strong>Predictable Rollout:</strong> The migration is carefully planned and executed, reducing risks of unexpected user issues post-launch.</li>



<li><strong>Simplified Support:</strong> Customer support teams can focus on the new system without maintaining old versions or dealing with fragmented migrations.</li>
</ul>



<p><strong>Challenges:</strong></p>



<ul>
<li><strong>High Complexity and Risk:</strong> Large-scale migrations require precise coordination and thorough testing. Any errors can affect the entire user base.</li>



<li><strong>Downtime Risk:</strong> The system might require a maintenance window, affecting availability during the migration process.</li>



<li><strong>Resource Intensive:</strong> Requires significant upfront investment in planning, development, and execution.</li>
</ul>



<p>Eager migration is ideal for platforms prioritizing consistency and control, especially when maintaining multiple systems or versions would be costly or impractical.</p>



<h3>Lazy Migration</h3>



<p>Lazy Migration, on the other hand, takes a more gradual approach. Rather than migrating all users at once, accounts are transferred only when users engage with the system (e.g., when they log in or perform an action).</p>



<p><strong>Advantages:</strong></p>



<ul>
<li><strong>Minimized Initial Risk:</strong> There is no need for a large-scale migration event, reducing the risk of major disruptions.</li>



<li><strong>Resource Optimization:</strong> Migration occurs in smaller batches over time, spreading out the operational load.</li>



<li><strong>Less Downtime:</strong> Users experience minimal disruption since the system doesn’t need to undergo a full-scale shutdown.</li>



<li><strong>User Self-Management:</strong> Users are naturally prompted to complete the migration process, reducing the need for preemptive handling.</li>
</ul>



<p><strong>Challenges:</strong></p>



<ul>
<li><strong>Fragmented State:</strong> For a period, some users will remain on the old system while others are on the new one, potentially causing inconsistencies.</li>



<li><strong>User Experience Dependency:</strong> Users must take action to complete the migration, which may frustrate or confuse less engaged users.</li>



<li><strong>Support Complexity:</strong> Customer support may need to handle issues on both the old and new systems until the migration is complete.</li>



<li><strong>Longer Transition Period:</strong> The full migration can take weeks or months, depending on user engagement patterns.</li>
</ul>



<p>Lazy migration works well when systems need to be highly available throughout the transition and when it’s acceptable for users to migrate at their own pace.</p>



<p><strong>Choosing the Right Strategy</strong></p>



<p>The choice between eager and lazy migration depends on several factors:</p>



<ul>
<li><strong>System Urgency:</strong> If rapid consistency is required, eager migration may be the better option.</li>



<li><strong>User Engagement Levels:</strong> For highly engaged users, lazy migration can allow a more seamless experience.</li>



<li><strong>Operational Resources:</strong> Eager migration requires more upfront resources, whereas lazy migration spreads the load over time.</li>



<li><strong>Tolerance for Downtime:</strong> If downtime is acceptable, eager migration can offer a cleaner transition. Otherwise, lazy migration provides continuity.</li>
</ul>



<p>Ultimately, both strategies have their place in migration planning. Some organizations may even adopt a <strong>hybrid approach</strong>, using eager migration for critical accounts while employing lazy migration for less critical users to balance risks and resources.</p>



<h2>Eager Migration: A Proactive Leap Forward</h2>



<p>Eager Migration represents a bold, comprehensive strategy for transitioning user accounts to a new system in one fell swoop, before the necessity for user login arises. This method boasts immediate system-wide consistency, a critical advantage for platforms striving for seamless user experiences across interfaces. However, it’s not without its complexities, especially when handling extensive user bases.</p>



<h3>The Promise of Uniformity and Immediate Integration</h3>



<p>The allure of Eager Migration lies in its promise of instant uniformity and integration. By transferring all user accounts to the new system in advance, platforms can ensure a consistent experience for both users and administrators from the outset. This approach eliminates the staggered transition periods often seen with other methods, aiming for a frictionless switch for all stakeholders involved.</p>



<h3>The Eager Migration Path: Steps to Seamless Transition</h3>



<p>Eager Migration unfolds in several calculated steps, beginning with the comprehensive transfer of user data from platforms like Auth0 to the new system. This includes the meticulous reformatting of user information to fit the new environment, ensuring password hashes and other vital details are seamlessly integrated.</p>



<h4>1. Dividing Users into Tenants (assuming multi-tenant support required)</h4>



<p>A pivotal step in Eager Migration is sorting users into appropriate tenants within the new system, often based on their email domain. This categorization facilitates better management and a more organized transition.</p>



<h4>2. Streamlining Sign-On Processes</h4>



<p>Maintaining familiar sign-in processes is crucial. Eager Migration allows users to log in using their previous credentials, minimizing disruptions and maintaining a sense of continuity.</p>



<h4>3. Finalizing the Move</h4>



<p>The migration culminates with a final review, ensuring all users are correctly moved, and their accounts function as expected. This phase is critical for identifying and addressing any lingering issues, ensuring a successful migration.</p>



<h4>4. Challenges and Considerations</h4>



<p>Despite its advantages, Eager Migration is not without challenges. The strategy requires meticulous planning and execution, especially concerning data compatibility and user privacy. Moreover, the potential for “login challenges” with certain password hashes, like bcrypt, underscores the need for thorough testing and possibly vendor support.</p>



<h2>Concluding Thoughts</h2>



<p>Eager Migration is a robust strategy for platforms seeking immediate consistency and minimal user disruption during digital identity system transitions. </p>



<p>While it demands significant upfront effort and careful consideration of potential challenges, its benefits in terms of user experience and system integrity are undeniable. </p>



<p>As digital platforms continue to evolve, strategies like Eager Migration offer a forward-thinking approach to managing the ever-important aspect of digital identity.</p>



<h2>Let’s walk through a working example</h2>



<h3>Scenario: <strong>Migrating from Auth0 to GCP Identity Platform</strong></h3>



<h4><strong><em>main.go</em></strong></h4>



<p>This supports both <strong>global</strong> and <strong>tenant-specific user migrations</strong>, providing flexibility for various migration scenarios</p>



<p>A simple server that runs on <a href="http://localhost:8080" rel="nofollow">http://localhost:8080</a> with <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a> enabled.  The server will expose two endpoints:</p>



<ul>
<li><a href="http://localhost:8080/migration/auth0/export-import-users" rel="nofollow">http://localhost:8080/migration/auth0/export-import-users</a></li>



<li><a href="http://localhost:8080/migration/auth0/tenant/" rel="nofollow">http://localhost:8080/migration/auth0/tenant/</a>{tenantId}/export-import-users</li>
</ul>



<p>The design allows migration of users specific to a <strong>tenant</strong>, identified by {tenantId} in the URL.  Both routes respond to <strong>GET</strong> and <strong>OPTIONS</strong> requests.</p>



<pre>package main

import (
	&#34;firebase-admin-auth-api-poc/handlers/auth0&#34;
	&#34;firebase-admin-auth-api-poc/handlers/middleware/cors&#34;
	&#34;firebase-admin-auth-api-poc/util&#34;
	firebase &#34;firebase.google.com/go/v4&#34;
	&#34;fmt&#34;
	&#34;github.com/gorilla/mux&#34;
	&#34;log&#34;
	&#34;net/http&#34;
)

func main() {
	fm := util.NewFirebaseManager()

	router := mux.NewRouter()

	configureMigration(router, fm)

	fmt.Println(&#34;Server started on :8080&#34;)
	log.Fatal(http.ListenAndServe(&#34;:8080&#34;, cors.EnableCORS(router.ServeHTTP)))
}

func configureMigration(router *mux.Router, fm *firebase.App) {
	router.HandleFunc(&#34;/migration/auth0/export-import-users&#34;, auth0.ExportImportUsersHandler(fm)).Methods(&#34;GET&#34;, &#34;OPTIONS&#34;)
	router.HandleFunc(&#34;/migration/auth0/tenant/{tenantId}/export-import-users&#34;, auth0.ExportImportUsersHandler(fm)).Methods(&#34;GET&#34;, &#34;OPTIONS&#34;)
}
</pre>



<h4><strong><em>export_import_users.go</em></strong></h4>



<p>This code provides an HTTP API endpoint to <strong>migrate users from Auth0 to Firebase</strong>. It ensures that users are seamlessly exported from Auth0, converted into a Firebase-compatible format, and imported into the specified Firebase tenant. It also <strong>handles common errors</strong> like missing tenant IDs and import failures, and limits imports to <strong>1000 users per batch</strong> to comply with GCP Identity Platform’s constraints.</p>



<pre>package auth0

import (
	&#34;encoding/json&#34;
	&#34;firebase-admin-auth-api-poc/handlers/auth0/helpers&#34;
	u &#34;firebase-admin-auth-api-poc/handlers/users&#34;
	&#34;firebase-admin-auth-api-poc/util&#34;
	firebase &#34;firebase.google.com/go/v4&#34;
	&#34;firebase.google.com/go/v4/auth&#34;
	&#34;fmt&#34;
	&#34;github.com/gorilla/mux&#34;
	&#34;net/http&#34;
)

type ExportImportResults struct {
	Users   []*helpers.UserToImport `json:&#34;users&#34;`
	Results *auth.UserImportResult  `json:&#34;results&#34;`
}

func ExportImportUsersHandler(fm *firebase.App) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {

		vars := mux.Vars(r)
		tenantId := vars[&#34;tenantId&#34;]
		if tenantId == &#34;&#34; {
			fmt.Println(&#34;unable to get tenant id&#34;)
			http.Error(w, &#34;Unable to get tenant id&#34;, http.StatusBadRequest)
		}

		users, err := exportAuth0Users()
		if err != nil {
			http.Error(w, &#34;Error exporting Auth0 users&#34;, http.StatusInternalServerError)
		}

		tc, err := util.GetTenantClient(fm, tenantId)
		if err != nil {
			fmt.Println(&#34;unable to get tenant client&#34;, err)
			http.Error(w, &#34;Unable to get tenant client&#34;, http.StatusInternalServerError)
		}

		importedUserResults, err := importAuth0Users(tc, users)
		if err != nil {
			http.Error(w, &#34;Error importing users&#34;, http.StatusInternalServerError)
		}

		response := generateResponse(users, importedUserResults)

		w.Header().Set(&#34;Content-Type&#34;, &#34;application/json&#34;)
		if err := json.NewEncoder(w).Encode(response); err != nil {
			http.Error(w, &#34;Error encoding users to JSON&#34;, http.StatusInternalServerError)
		}
	}
}

func exportAuth0Users() ([]helpers.User, error) {
	// Get Auth0 Users
	users, err := helpers.ExportAuth0UsersJob()
	if err != nil {
		fmt.Println(&#34;error exporting users from Auth0&#34;, err)
	}

	return users, err
}

func importAuth0Users(tc *auth.TenantClient, users []helpers.User) (*auth.UserImportResult, error) {
	usersToImport := helpers.ConvertFromAuth0ToFirebaseUserToImport(users)

        // GCP Identity Platform has a limit of 1000 users per import, if you have more users
        // you need expand this code to break this into chunks of 1000
	importUserResults, err := u.ImportUsers(tc, usersToImport)
	if err != nil {
		return nil, fmt.Errorf(&#34;error importing users: %w&#34;, err)
	}

	return importUserResults, err
}

func generateResponse(users []helpers.User, importResults *auth.UserImportResult) ExportImportResults {
	usersResult := helpers.ConvertFromAuth0ToLocalUserToImport(users)

	return ExportImportResults{
		Users:   usersResult,
		Results: importResults,
	}
}
</pre>



<p><strong>Struct Definition:</strong></p>



<ul>
<li>ExportImportResults: Holds the user data and the import results for the response.</li>
</ul>



<p><strong>HTTP Handler:</strong></p>



<ul>
<li>ExportImportUsersHandler(fm *firebase.App): This function returns an HTTP handler that coordinates the <strong>export and import of users</strong> between Auth0 and Firebase.</li>
</ul>



<p><strong>Workflow:</strong></p>



<ul>
<li>Extracts the tenantId from the request path.</li>



<li>Exports users from Auth0 using exportAuth0Users().</li>



<li>Gets a Firebase tenant client for the given tenantId using util.GetTenantClient().</li>



<li>Imports the exported users into Firebase using importAuth0Users().</li>



<li>Generates and sends the response in <strong>JSON</strong> format with the import results.</li>
</ul>



<p>Exporting Users from Auth0:</p>



<ul>
<li>exportAuth0Users(): Calls a helper function ExportAuth0UsersJob() to retrieve users from Auth0.</li>
</ul>



<p>Importing Users into Firebase:</p>



<ul>
<li>importAuth0Users(tc *auth.TenantClient, users []helpers.User):</li>



<li>Converts Auth0 users to Firebase-compatible user objects.</li>



<li>Imports users into Firebase, with a <strong>reminder to handle import limits (1000 users per batch)</strong> if necessary.</li>
</ul>



<p>Generating the Response:</p>



<ul>
<li>generateResponse(): Prepares a response containing both the exported users and the import results.</li>
</ul>



<p><strong>Error Handling:</strong></p>



<ul>
<li>If there are <strong>missing tenant IDs</strong>, or <strong>export/import failures</strong>, appropriate <strong>HTTP error responses</strong> are returned.</li>



<li>Uses http.Error() to send error messages in case of issues during processing.</li>
</ul>



<h4><strong><em>Example auth0-example-config.json</em></strong></h4>



<pre>{
  &#34;auth0domain&#34;: &#34;REPLACE WITH AUTH0 DOMAIN&#34;,
  &#34;applications&#34;: {
    &#34;Auth0 Management API&#34;: {
      &#34;auth0clientID&#34;: &#34;REPLACE WITH CLIENT ID&#34;,
      &#34;auth0clientsecret&#34;: &#34;REPLACE WITH CLIENT SECRET&#34;,
      &#34;auth0audience&#34;: &#34;https://REPLACE WITH AUTH0 DOMAIN/api/v2/&#34;
    }
  }
}</pre>



<h4><strong><em>auth0.go</em></strong></h4>



<p>This code is for exporting user data from <strong>Auth0</strong>. It provides functions to initiate, monitor, and download the user export job from Auth0, and it processes the exported data for further use.</p>



<p><strong>Reference:</strong> Export User Passwords from Auth0 – <a href="https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data">https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data</a></p>



<p><strong>How It Works:</strong></p>



<ul>
<li><strong>Configuration Handling:</strong>
<ul>
<li>Loads <strong>Auth0 credentials</strong> from a local JSON file.</li>
</ul>
</li>



<li><strong>User Export Process</strong>:
<ul>
<li>For each configured Auth0 application:
<ul>
<li><strong>Creates an export job</strong> through the Auth0 API.</li>



<li><strong>Polls the job status</strong> until it completes.</li>



<li><strong>Downloads the exported file</strong> from the provided location.</li>



<li><strong>Extracts user data</strong> from the file.</li>



<li><strong>Handling GZIP Compression</strong>:
<ul>
<li>If the downloaded file is GZIP-compressed, it decompresses it before extracting the user records.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>



<pre>package helpers

import (
	&#34;bufio&#34;
	&#34;bytes&#34;
	&#34;compress/gzip&#34;
	&#34;context&#34;
	&#34;encoding/json&#34;
	&#34;fmt&#34;
	&#34;golang.org/x/oauth2/clientcredentials&#34;
	&#34;io&#34;
	&#34;io/ioutil&#34;
	&#34;net/http&#34;
	&#34;strings&#34;
	&#34;time&#34;
)

// config

type Config struct {
	Auth0Domain  string                 `json:&#34;auth0domain&#34;`
	Applications map[string]Application `json:&#34;applications&#34;`
}

type Application struct {
	Auth0ClientID     string `json:&#34;auth0clientID&#34;`
	Auth0ClientSecret string `json:&#34;auth0clientsecret&#34;`
	Auth0Audience     string `json:&#34;auth0audience&#34;`
}

// response

type JobStatus struct {
	Status   string `json:&#34;status&#34;`
	Location string `json:&#34;location,omitempty&#34;`
}

type JobResponse struct {
	ID string `json:&#34;id&#34;`
}

func ExportAuth0UsersJob() ([]User, error) {

	clientConfig, err := getClientConfig()
	if err != nil {
		return nil, fmt.Errorf(&#34;failed to get client config: %w&#34;, err)
	}

	var domain = clientConfig.Auth0Domain

	var allUsers []User // Aggregate users from all applications

	for appName, appDetails := range clientConfig.Applications {

		fmt.Printf(&#34;Auth0 app: %s\n&#34;, appName)

		client := getClient(domain, appDetails)

		jobResponse, err := createExportJob(domain, client)
		if err != nil {
			return nil, fmt.Errorf(&#34;failed to create job: %w&#34;, err)
		}

		jobStatus, err := pollExportJobStatus(domain, client, *jobResponse)
		if err != nil {
			return nil, fmt.Errorf(&#34;failed to retrieve job status: %w&#34;, err)
		}

		// Download the file from the location URL
		fileResp, err := downloadFile(*jobStatus)
		if err != nil {
			return nil, fmt.Errorf(&#34;failed to download the exported file: %w&#34;, err)
		}

		users, err := extractUsersFromFile(fileResp)
		if err != nil {
			return nil, fmt.Errorf(&#34;failed to extract users from file: %w&#34;, err)
		}

		allUsers = append(allUsers, users...)
	}

	return allUsers, nil
}

func getClientConfig() (*Config, error) {
	// Open and read the JSON file
	filePath := &#34;./config/auth0-example-config.json&#34;
	file, err := ioutil.ReadFile(filePath)
	if err != nil {
		fmt.Printf(&#34;Error reading file: %s\n&#34;, err)
		return nil, err
	}

	// Unmarshal the JSON content into Config struct
	var config Config
	err = json.Unmarshal(file, &amp;config)
	if err != nil {
		fmt.Printf(&#34;Error unmarshalling JSON: %s\n&#34;, err)
		return nil, err
	}

	return &amp;config, nil
}

func getClient(domain string, appDetails Application) *http.Client {
	ctx := context.Background()

	clientConfig := clientcredentials.Config{
		ClientID:     appDetails.Auth0ClientID,
		ClientSecret: appDetails.Auth0ClientSecret,
		TokenURL:     fmt.Sprintf(&#34;https://%s/oauth/token&#34;, domain),
		Scopes:       []string{&#34;read:users&#34;},
		EndpointParams: map[string][]string{
			&#34;audience&#34;: {appDetails.Auth0Audience},
		},
	}

	client := clientConfig.Client(ctx)

	return client
}

func createExportJob(domain string, client *http.Client) (*JobResponse, error) {
	jobRequest := ExportJobRequest{
		Format: &#34;json&#34;,
		Fields: []Field{
			{Name: &#34;app_metadata&#34;},
			{Name: &#34;blocked&#34;},
			{Name: &#34;created_at&#34;},
			{Name: &#34;email&#34;},
			{Name: &#34;email_verified&#34;},
			{Name: &#34;family_name&#34;},
			{Name: &#34;given_name&#34;},
			{Name: &#34;identities&#34;},
			{Name: &#34;last_ip&#34;},
			{Name: &#34;last_login&#34;},
			{Name: &#34;logins_count&#34;},
			{Name: &#34;name&#34;},
			{Name: &#34;nickname&#34;},
			{Name: &#34;phone_number&#34;},
			{Name: &#34;phone_verified&#34;},
			{Name: &#34;picture&#34;},
			{Name: &#34;updated_at&#34;},
			{Name: &#34;user_id&#34;},
			{Name: &#34;user_metadata&#34;},
			{Name: &#34;username&#34;},
			// Add other fields as needed.
		},
	}

	requestBody, _ := json.Marshal(jobRequest)
	resp, err := client.Post(fmt.Sprintf(&#34;https://%s/api/v2/jobs/users-exports&#34;, domain), &#34;application/json&#34;, bytes.NewBuffer(requestBody))
	if err != nil {
		return nil, fmt.Errorf(&#34;failed to start export job: %w&#34;, err)
	}
	defer resp.Body.Close()

	var jobResponse JobResponse
	if err := json.NewDecoder(resp.Body).Decode(&amp;jobResponse); err != nil {
		return nil, fmt.Errorf(&#34;failed to decode job response: %w&#34;, err)
	}

	return &amp;jobResponse, nil
}

func pollExportJobStatus(domain string, client *http.Client, jobResponse JobResponse) (*JobStatus, error) {

	// Poll the job status until it&#39;s complete to get the file location
	var jobStatus JobStatus
	for {
		time.Sleep(5 * time.Second) // Wait before polling again

		jobStatusResp, _ := client.Get(fmt.Sprintf(&#34;https://%s/api/v2/jobs/%s&#34;, domain, jobResponse.ID))
		defer jobStatusResp.Body.Close()

		json.NewDecoder(jobStatusResp.Body).Decode(&amp;jobStatus)

		if jobStatus.Status == &#34;completed&#34; &amp;&amp; jobStatus.Location != &#34;&#34; {
			fmt.Printf(&#34;File ready to download \n&#34;)
			break
		}
	}

	return &amp;jobStatus, nil
}

func downloadFile(jobStatus JobStatus) (*http.Response, error) {
	fileResp, err := http.Get(jobStatus.Location)
	if err != nil {
		return nil, fmt.Errorf(&#34;failed to download the exported file: %w&#34;, err)
	}

	return fileResp, nil
}

func extractUsersFromFile(fileResp *http.Response) ([]User, error) {
	defer fileResp.Body.Close()

	var reader io.Reader = fileResp.Body
	if strings.HasSuffix(fileResp.Request.URL.Path, &#34;.gz&#34;) {
		gzipReader, err := gzip.NewReader(fileResp.Body)
		if err != nil {
			return nil, fmt.Errorf(&#34;failed to create gzip reader: %w&#34;, err)
		}
		defer gzipReader.Close()
		reader = gzipReader
	}

	var users []User
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		var user User
		if err := json.Unmarshal(scanner.Bytes(), &amp;user); err != nil {
			// Handle the error or log it, but don&#39;t necessarily return yet as other records might be valid
			fmt.Printf(&#34;Error parsing user record: %v\n&#34;, err)
			continue
		}
		users = append(users, user)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf(&#34;error reading user records: %w&#34;, err)
	}

	return users, nil
}


</pre>



<p><strong>Configuration Handling:</strong></p>



<ul>
<li>Config<strong> Struct:</strong> Stores the <strong>Auth0 domain</strong> and <strong>application credentials</strong> (client ID, client secret, and audience) for multiple applications.</li>



<li>getClientConfig(): Reads a JSON configuration file containing Auth0 credentials and returns a Config object.</li>
</ul>



<p><strong>User Export Process:</strong></p>



<p>Export Job Management:</p>



<ul>
<li>ExportAuth0UsersJob():</li>
</ul>



<p>The main function to <strong>export all users from Auth0</strong>. It follows these steps:</p>



<ul>
<li>Loads the Auth0 <strong>configuration</strong>.</li>



<li>Iterates over each application in the configuration and:
<ul>
<li>Initializes an <strong>HTTP client</strong> for Auth0.</li>



<li>Creates an <strong>export job</strong> for each application.</li>



<li><strong>Polls the job status</strong> until it completes.</li>



<li><strong>Downloads the exported file</strong> once the job is completed.</li>



<li><strong>Extracts user data</strong> from the downloaded file and adds it to a consolidated user list.</li>
</ul>
</li>
</ul>



<ul>
<li>createExportJob():</li>
</ul>



<p>Creates a user export job on the Auth0 API by sending a <strong>POST request</strong>. It specifies the format (json) and the <strong>user fields</strong> to be included in the export.</p>



<ul>
<li>pollExportJobStatus():</li>
</ul>



<p>Continuously polls the Auth0 API for the <strong>job’s status</strong>. Once the status is marked as “completed”, the function returns the <strong>file location</strong> for download.</p>



<p>Downloading and Extracting Users:</p>



<ul>
<li>downloadFile():</li>
</ul>



<p>Downloads the <strong>exported user data</strong> from the location provided in the job status.</p>



<ul>
<li>extractUsersFromFile():</li>
</ul>



<p>Reads the downloaded file (supports <strong>GZIP compression</strong>) and <strong>parses user records</strong> in JSON format. It uses a <strong>scanner</strong> to read the file line-by-line and unmarshals each user record into a User<strong> struct</strong>.</p>



<p>Auth0 Client Initialization:</p>



<ul>
<li>getClient():</li>
</ul>



<p>Creates an <strong>OAuth2 HTTP client</strong> using the <strong>client credentials grant</strong>. This client is used to communicate with the Auth0 API.</p>



<p><strong>Error Handling:</strong></p>



<ul>
<li><strong>File Read Errors</strong>: If the configuration file cannot be read, it prints the error and returns it.</li>



<li><strong>Job Status Errors</strong>: If the job fails or the status check fails, it logs an error and returns.</li>



<li><strong>User Parsing Errors</strong>: If individual user records fail to parse, it <strong>logs the error</strong> and continues parsing the remaining records.</li>
</ul>



<h4><strong><em>Example your-auth0-users-passwords-exported.json</em></strong></h4>



<p>Credential in this file, if you use them, you can test the login using:</p>



<ul>
<li>Username – dummy-1@example.com, Password – dummy-one@example.com</li>



<li>Username – dummy-2@example.com, Password – dummy-two@example.com</li>



<li>Username – dummy-3@example.com, Password – dummy-three@example.com</li>
</ul>



<pre>{
  &#34;_id&#34;: {
    &#34;$oid&#34;: &#34;65cae5bdbb371546863e5b6d&#34;
  },
  &#34;email&#34;: &#34;dummy-1@example.com&#34;,
  &#34;email_verified&#34;: true,
  &#34;tenant&#34;: &#34;my-demo&#34;,
  &#34;connection&#34;: &#34;Username-Password-Authentication&#34;,
  &#34;passwordHash&#34;: &#34;$2y$10$xXuqs5YJksMuvYPtjjUowez97L2T4lLmS.oP5aHvb8SgAY/mLqfsq&#34;,
  &#34;_tmp_is_unique&#34;: true,
  &#34;version&#34;: &#34;1.1&#34;,
  &#34;identifiers&#34;: [
    {
      &#34;type&#34;: &#34;email&#34;,
      &#34;value&#34;: &#34;dummy-1@example.com&#34;,
      &#34;verified&#34;: true
    }
  ]
}
{
  &#34;_id&#34;: {
    &#34;$oid&#34;: &#34;65c1b314efba7964db2cbb35&#34;
  },
  &#34;email&#34;: &#34;dummy-2@example.com&#34;,
  &#34;email_verified&#34;: true,
  &#34;tenant&#34;: &#34;my-demo&#34;,
  &#34;connection&#34;: &#34;Username-Password-Authentication&#34;,
  &#34;passwordHash&#34;: &#34;$2y$10$D/Jbzci35tE4pdbbkqGjdOrdcQPU3lrDm1IWImP63AQwIXmwcE1SC&#34;,
  &#34;_tmp_is_unique&#34;: true,
  &#34;version&#34;: &#34;1.1&#34;,
  &#34;identifiers&#34;: [
    {
      &#34;type&#34;: &#34;email&#34;,
      &#34;value&#34;: &#34;dummy-2@example.com&#34;,
      &#34;verified&#34;: true
    }
  ]
}
{
  &#34;_id&#34;: {
    &#34;$oid&#34;: &#34;65a9ae3127729943e0665e29&#34;
  },
  &#34;email&#34;: &#34;dummy-3@example.com&#34;,
  &#34;email_verified&#34;: true,
  &#34;tenant&#34;: &#34;my-demo&#34;,
  &#34;connection&#34;: &#34;Username-Password-Authentication&#34;,
  &#34;passwordHash&#34;: &#34;$2y$10$xJ2Pi9M.pAP0L6CdoXL6cu/DBiOkBPN9VtVJL7ZreNeRa.Qi.hgwO&#34;,
  &#34;_tmp_is_unique&#34;: true,
  &#34;version&#34;: &#34;1.1&#34;,
  &#34;identifiers&#34;: [
    {
      &#34;type&#34;: &#34;email&#34;,
      &#34;value&#34;: &#34;dummy-3@example.com&#34;,
      &#34;verified&#34;: true
    }
  ]
}</pre>



<h4><strong><em>convert_auth0_to_local_or_firebase_struct.go</em></strong></h4>



<p>This code is for <strong>converting user objects</strong>, <strong>retrieving passwords</strong> from a local file, and <strong>mapping user identities</strong> for seamless migration to Firebase. </p>



<p><strong>Action:</strong> replace “your-auth0-users-passwords-exported” with your exported filename.</p>



<p><strong>How It Works:</strong></p>



<ul>
<li><strong>User Conversion:</strong>
<ul>
<li>The main conversion function, ConvertFromAuth0ToFirebaseUserToImport(), processes <strong>Auth0 user data</strong> and converts it to <strong>Firebase-compatible</strong> objects.</li>



<li><strong>User identities</strong> (providers) are converted and attached to each user.</li>
</ul>
</li>



<li><strong>Password Handling:</strong>
<ul>
<li><strong>User passwords</strong> are read from a <strong>local JSON file</strong>.</li>



<li>Each user is matched with their password (if available), and the password hash is attached to the Firebase user object during conversion.</li>
</ul>
</li>



<li><strong>Provider Data Transformation:</strong>
<ul>
<li>Auth0 user identities are mapped to either <strong>Firebase providers</strong> or a <strong>local provider format</strong>, depending on the function used.</li>
</ul>
</li>
</ul>



<pre>package helpers

import (
	&#34;bufio&#34;
	&#34;encoding/json&#34;
	&#34;firebase-admin-auth-api-poc/handlers/users/helpers&#34;
	&#34;firebase.google.com/go/v4/auth&#34;
	&#34;fmt&#34;
	&#34;os&#34;
)

// Auth0 Structures

type Identity struct {
	UserID      string                 `json:&#34;user_id&#34;`
	Provider    string                 `json:&#34;provider&#34;`
	ProfileData map[string]interface{} `json:&#34;profileData&#34;`
}

type User struct {
	UserID        string                 `json:&#34;user_id&#34;`
	Email         string                 `json:&#34;email&#34;`
	EmailVerified bool                   `json:&#34;email_verified&#34;`
	Identities    []Identity             `json:&#34;identities&#34;`
	Name          string                 `json:&#34;name&#34;`
	Picture       string                 `json:&#34;picture&#34;`
	UserMetadata  map[string]interface{} `json:&#34;user_metadata&#34;`
}

type ExportJobRequest struct {
	ConnectionID string  `json:&#34;connection_id,omitempty&#34;` // Optional
	Format       string  `json:&#34;format&#34;`
	Limit        int     `json:&#34;limit,omitempty&#34;` // Optional
	Fields       []Field `json:&#34;fields&#34;`
}

type Field struct {
	Name string `json:&#34;name&#34;`
}

type UserPassword struct {
	ID            ID           `json:&#34;_id&#34;`
	EmailVerified bool         `json:&#34;email_verified&#34;`
	Email         string       `json:&#34;email&#34;`
	PasswordHash  string       `json:&#34;passwordHash,omitempty&#34;`
	Tenant        string       `json:&#34;tenant&#34;`
	Connection    string       `json:&#34;connection&#34;`
	TmpIsUnique   bool         `json:&#34;_tmp_is_unique&#34;`
	Identifiers   []Identifier `json:&#34;identifiers&#34;`
	Version       string       `json:&#34;version&#34;`
}

type ID struct {
	Oid string `json:&#34;$oid&#34;`
}

type Identifier struct {
	Type     string `json:&#34;type&#34;`
	Value    string `json:&#34;value&#34;`
	Verified bool   `json:&#34;verified&#34;`
}

// Local Structures

type UserToImport struct {
	UID           string                  `json:&#34;uid,omitempty&#34;`
	Email         string                  `json:&#34;email&#34;`
	DisplayName   string                  `json:&#34;displayName&#34;`
	PhotoURL      string                  `json:&#34;photoURL&#34;`
	PhoneNumber   string                  `json:&#34;phoneNumber&#34;`
	Metadata      map[string]interface{}  `json:&#34;userMetadata,omitempty&#34;`
	CustomClaims  map[string]interface{}  `json:&#34;customClaims,omitempty&#34;`
	Disabled      bool                    `json:&#34;disabled&#34;`
	EmailVerified bool                    `json:&#34;emailVerified&#34;`
	ProviderData  []*helpers.UserProvider `json:&#34;userProviders,omitempty&#34;`
}

type UserAndMetadataToImport struct {
	UserToImport *auth.UserToImport     `json:&#34;userToImport&#34;`
	Metadata     map[string]interface{} `json:&#34;userMetadata,omitempty&#34;`
}

func ConvertFromAuth0ToFirebaseUserToImport(users []User) []UserAndMetadataToImport {
	var usersToImport []UserAndMetadataToImport

	usersPasswords, err := getUsersPasswords() // Retrieve passwords once
	if err != nil {
		fmt.Printf(&#34;Unable to get users passwords: %s\n&#34;, err)
		return nil // Or handle the error more gracefully
	}

	for _, u := range users {
		userImport := (&amp;auth.UserToImport{}).
			UID(u.UserID).
			Email(u.Email).
			DisplayName(u.Name).
			PhotoURL(u.Picture).
			EmailVerified(u.EmailVerified).
			PasswordHash(getPasswordHashForUser(u, usersPasswords)). // Use the safely obtained passwordHash
			ProviderData(ConvertFromAuth0ToFirebaseUserProviders(u.Identities))

		metadata := u.UserMetadata

		usersToImport = append(usersToImport, UserAndMetadataToImport{
			UserToImport: userImport,
			Metadata:     metadata,
		})
	}

	return usersToImport
}

func ConvertFromAuth0ToLocalUserToImport(users []User) []*UserToImport {
	var usersToImport []*UserToImport

	for _, u := range users {
		userImport := UserToImport{
			UID:           u.UserID,
			Email:         u.Email,
			DisplayName:   u.Name,
			PhotoURL:      u.Picture,
			EmailVerified: u.EmailVerified,
			ProviderData:  ConvertFromAuth0ToLocalUserProviders(u.Identities),
		}

		// TODO set Metadata

		usersToImport = append(usersToImport, &amp;userImport)
	}

	return usersToImport
}

func ConvertFromAuth0ToFirebaseUserProviders(identities []Identity) []*auth.UserProvider {
	var providerData []*auth.UserProvider // Construct the slice of providers here

	for _, identity := range identities {
		provider := helpers.UserProvider{
			UID:        identity.UserID,
			ProviderID: identity.Provider,
		}
		if email, ok := identity.ProfileData[&#34;email&#34;].(string); ok {
			provider.Email = email
		}
		// Append the converted provider to the slice
		providerData = append(providerData, helpers.ConvertToFirebaseUserProvider(&amp;provider))
	}

	return providerData
}

func ConvertFromAuth0ToLocalUserProviders(identities []Identity) []*helpers.UserProvider {
	var providerData []*helpers.UserProvider // Construct the slice of providers here

	for _, identity := range identities {
		provider := helpers.UserProvider{
			UID:        identity.UserID,
			ProviderID: identity.Provider,
		}
		if email, ok := identity.ProfileData[&#34;email&#34;].(string); ok {
			provider.Email = email
		}
		// Append the converted provider to the slice
		providerData = append(providerData, &amp;provider)
	}

	return providerData
}

func getUsersPasswords() ([]UserPassword, error) {
	// Open the JSON file
	filePath := &#34;./data/your-auth0-users-passwords-exported.json&#34;
	file, err := os.Open(filePath)
	if err != nil {
		fmt.Printf(&#34;Error opening file: %s\n&#34;, err)
		return nil, err
	}
	defer file.Close()

	var userPasswords []UserPassword
	scanner := bufio.NewScanner(file)

	// Read and unmarshal each line (JSON object) into the slice
	for scanner.Scan() {
		var userPassword UserPassword
		err := json.Unmarshal(scanner.Bytes(), &amp;userPassword)
		if err != nil {
			fmt.Printf(&#34;Error unmarshalling user password JSON: %s\n&#34;, err)
			// Decide how to handle errors; you might continue, return, or collect errors
			return nil, err
		}
		userPasswords = append(userPasswords, userPassword)
	}

	if err := scanner.Err(); err != nil {
		fmt.Printf(&#34;Error reading file: %s\n&#34;, err)
		return nil, err
	}

	return userPasswords, nil
}

func findUserPassword(user User, usersPasswords []UserPassword) *UserPassword {
	for _, userPassword := range usersPasswords {
		if userPassword.Email == user.Email {
			return &amp;userPassword
		}
	}
	return nil
}

func getPasswordHashForUser(user User, users []UserPassword) []byte {
	userPassword := findUserPassword(user, users) // Correctly use the result

	// fmt.Println(&#34;Email: &#34;, u.Email, &#34; Password: &#34;, userPassword.PasswordHash, &#34; Connection: &#34;, userPassword.Connection)

	var passwordHash []byte
	if userPassword != nil &amp;&amp; userPassword.PasswordHash != &#34;&#34; {
		passwordHash = []byte(userPassword.PasswordHash)
	} else {
		fmt.Println(&#34;No password found or userPassword is nil&#34;)
		// fmt.Println(&#34;No password found or userPassword is nil for Email &#34;, u.Email, &#34; and connection &#34;, userPassword.Connection)
	}

	return passwordHash
}
</pre>



<p><strong>Auth0 User Structures:</strong></p>



<ul>
<li>Identity: Represents a user identity from an external provider (e.g., Google, Facebook) with associated profile data.</li>



<li>User: Represents an <strong>Auth0 user</strong> with properties such as user_id, email, name, and associated metadata.</li>
</ul>



<p><strong>User Conversion Functions:</strong></p>



<ul>
<li>ConvertFromAuth0ToFirebaseUserToImport():
<ul>
<li>Converts <strong>Auth0 users to Firebase-compatible users</strong>.</li>



<li>It also <strong>retrieves user passwords</strong> and assigns them using getPasswordHashForUser().</li>



<li>For each user, it <strong>transforms their provider data</strong> (e.g., Google, Facebook) into Firebase’s provider format.</li>
</ul>
</li>



<li>ConvertFromAuth0ToLocalUserToImport():
<ul>
<li>Converts Auth0 users into a <strong>local format</strong> (UserToImport), which can be used for Firebase imports.</li>



<li>Sets basic fields such as UID, Email, and DisplayName.</li>
</ul>
</li>
</ul>



<p><strong>User Provider Conversion:</strong></p>



<ul>
<li>ConvertFromAuth0ToFirebaseUserProviders():
<ul>
<li>Converts <strong>Auth0 user identities</strong> to <strong>Firebase providers</strong>.</li>



<li>Maps properties like user_id and provider into a format Firebase understands.</li>
</ul>
</li>



<li>ConvertFromAuth0ToLocalUserProviders():
<ul>
<li>Converts Auth0 identities into a <strong>local provider format</strong> (UserProvider), which is used when importing users locally.</li>
</ul>
</li>
</ul>



<p><strong>Password Handling:</strong></p>



<ul>
<li>getUsersPasswords():
<ul>
<li>Reads a <strong>JSON file</strong> containing user passwords from the local filesystem.</li>



<li>Parses the file line-by-line, unmarshaling each line into a UserPassword struct.</li>
</ul>
</li>



<li>findUserPassword():
<ul>
<li>Searches for a user’s password by matching the email address in the <strong>password records</strong>.</li>
</ul>
</li>



<li>getPasswordHashForUser():
<ul>
<li>Retrieves the <strong>password hash</strong> for a given user.</li>



<li>If no password is found, it prints an appropriate message and returns an empty hash.</li>
</ul>
</li>
</ul>



<p><strong>Data Structures for Firebase Migration:</strong></p>



<ul>
<li>UserToImport: Represents a user object for Firebase import with fields like UID, Email, PhotoURL, and PhoneNumber.</li>



<li>UserAndMetadataToImport: A wrapper structure combining <strong>user import data</strong> and associated <strong>metadata</strong>.</li>
</ul>



<p><strong>Error Handling:</strong></p>



<ul>
<li><strong>Password File Errors:</strong> If the password file fails to open or parse, an error message is printed, and the function exits gracefully.</li>



<li><strong>User Parsing Errors:</strong> If a user’s password or identity data fails to parse, the code logs the error and continues processing other users.</li>
</ul>



<p>To log in and test the credentials migrated across you will need to have a client that connects to the tenants, this blog post does not contain the instructions to configure that, however you can look at <a href="https://github.com/firebase/firebaseui-web">https://github.com/firebase/firebaseui-web</a> for a starting point to help you establish a client for quick validation of your data.</p>



<h2>Did this help?</h2>



<ul>
<li><strong>Like, comment and share this article</strong></li>



<li><strong>Follow this blog</strong> to receive notifications of new postings</li>



<li><strong>View</strong> <a href="https://robertleggett.blog/">previous postings</a></li>
</ul>
	</div></div>
        </section>
    </article>
</main>
</body>
</html>
