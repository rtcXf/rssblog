<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>A month of /proc | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://ops.tips/blog/a-month-of-proc/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>A month of /proc</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div>

  <header>
    
    <h2 itemprop="description">The challenge has been set - a month of blog posts around procfs!</h2>

    
  </header>

  <article itemtype="http://schema.org/NewsArticle">
    <section itemprop="articleBody">
      <p>Hey!</p>
<p>I’ve been wanting to better understand what are some of the capabilities of <a href="https://www.kernel.org/doc/Documentation/filesystems/proc.txt">procfs (<code>/proc</code>)</a>, so I thought of a little challenge for me:</p>
<ul>
<li>for each day, <strong>for 30 days</strong>, I’ll be posting a new article about a single file under <code>/proc</code> that should be useful for someone either introspecting a system (or wanting to mutate some kernel param).</li>
</ul>
<p>Given that <em>so many</em> tools touch the <code>/proc</code> mountpoint to gather information, and that it’s such a great place to learn more about where you can look for the reasons why a given process or the entire system is malfunctioning, I bet this it going to be great for many of the readers.</p>


<p>Differently from the many other articles around the web covering <code>/proc</code>, the focus of this series is more on the details and internals of each call.</p>
<p>For instance, the plan is not only to cover questions like:</p>
<blockquote>
<p>What is <code>/proc/&lt;pid&gt;/fd</code>?</p>
</blockquote>
<p>But to include answers to questions like:</p>
<blockquote>
<p>When I call <code>ls /proc/&lt;pid&gt;/fd</code>, what happens under the hood?</p>
</blockquote>
<p>I still don’t have a full list of which files I’ll be touching (and in what order), so, please, let me know if you’d like me to cover a specific one!</p>
<p>This article will be updated whenever a new post comes out, so feel free to keep track of this one.</p>
<p>Have a good one!</p>
<h3 id="the-articles-so-far">The articles so far</h3>
<ol>
<li>
<p><a href="https://ops.tips/blog/what-is-slash-proc"><strong>What is /proc?</strong></a> - as the first article in the series, this one focuses on the fundamentals around <a href="https://www.kernel.org/doc/Documentation/filesystems/proc.txt"><code>procfs</code></a>, the underlying implementation that responds to calls to <code>/proc</code>, as well as <a href="https://www.kernel.org/doc/Documentation/filesystems/vfs.txt"><code>vfs</code></a>.</p>
</li>
<li>
<p><a href="https://ops.tips/blog/how-is-proc-able-to-list-pids"><strong>How is /proc able to list process IDs?</strong></a> - given that directories are files, the first file I wanted to look for was the root directory of <code>/proc</code>. In this article, I go through how listing directories work in Linux and at which point procfs takes care of searching for PIDs and returning them as directory entries for the user.</p>
</li>
<li>
<p><a href="https://ops.tips/blog/why-top-inside-container-wrong-memory/"><strong>Why top and free inside containers don’t show the correct container memory?</strong></a> - this one covers some of the underlying aspects of how containers limits resources (tip: <code>cgroups</code>!) and why is the retrieval of memory information uncontained. If you’re into k8s and Docker, check this one out!</p>
</li>
<li>
<p><a href="https://ops.tips/blog/proc-pid-limits-under-the-hood"><strong>Process limits under the hood</strong></a> - go through the internals of implementing a <code>ulimit</code> utility in C, inspecting how the Kernel limits the number of open files for a given process and then finally seeing how <code>/proc/pid/limits</code> works. Expect some tracing and a bunch of Kernel methods exposed!</p>
</li>
<li>
<p><a href="https://ops.tips/blog/using-procfs-to-get-process-stack-trace"><strong>Using /proc to get a process&#39; current stack trace</strong></a> - go through the process of creating a simple TCP server that blocks, and then using <code>/proc</code> to identify the stack trace of the method that led the kernel to block at a given syscall. In this post we also look at how that C stack compares to one generated by the Go runtime.</p>
</li>
<li>
<p><a href="https://ops.tips/blog/how-linux-creates-sockets/"><strong>How Linux creates sockets and counts them</strong></a> - a deep dive into how the Linux kernel creates a Socket under the hood, and how it keeps track of the number of sockets that it has allocated.</p>
</li>
</ol>
<div>

<p>Would you like to keep up with the articles?</p>
<p><a href="https://google.us3.list-manage.com/subscribe/post?u=1941019739d6aa1a25eda3787&amp;id=ff9c3cc11e"><strong>Click here</strong></a> to signup for the newsletter!</p>

</div>


    </section>
  </article>

</div></div>
        </section>
    </article>
</main>
</body>
</html>
