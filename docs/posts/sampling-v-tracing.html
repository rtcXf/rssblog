<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sampling v. tracing | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/perf-tracing/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Sampling v. tracing</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p>Perf is probably the most widely used general purpose performance debugging tool on Linux. There are multiple contenders for the #2 spot, and, like perf, they&#39;re sampling profilers. Sampling profilers are great. They tend to be easy-to-use and low-overhead compared to most alternatives. However, there are large classes of performance problems sampling profilers can&#39;t debug effectively, and those problems are becoming more important.</p> <p>For example, consider a Google search query. Below, we have a diagram of how a query is carried out. Each of the black boxes is a rack of machines and each line shows a remote procedure call (RPC) from one machine to another.</p>  <p><img src="https://danluu.com/images/intel-cat/search_query.png" width="640" height="352"/></p> <p>The diagram shows a single search query coming in, which issues RPCs to over a hundred machines (shown in green), each of which delivers another set of requests to the next, lower level (shown in blue). Each request at that lower level also issues a set of RPCs, which aren&#39;t shown because there&#39;s too much going on to effectively visualize. At that last leaf level, the machines do 1ms-2ms of work, and respond with the result, which gets propagated and merged on the way back, until the search result is assembled. While that&#39;s happening, on any leaf machine, 20-100 other search queries will touch the same machine. A single query might touch a couple thousand machines to get its results. If we look at the latency distribution for RPCs, we&#39;d expect that with that many RPCs, any particular query will see a 99%-ile worst case (tail) latency; <a href="http://research.google.com/pubs/pub40801.html">and much worse than mere 99%-ile, actually</a>.</p> <p>That latency translates directly into money. It&#39;s now well established that adding user latency reduces ad clicks, reduces the odds that a user will complete a transaction and buy something, reduces the odds that a user will come back later and become a repeat customer, etc. Over the past ten to fifteen years, the understanding that tail latency is an important factor in determining user latency, and that user latency translates directly to money, has trickled out from large companies like Google into the general consciousness. But debugging tools haven&#39;t kept up.</p> <p>Sampling profilers, the most common performance debugging tool, are notoriously bad at debugging problems caused by tail latency because they aggregate events into averages. But tail latency is, by definition, not average.</p> <p>For more on this, let&#39;s look at <a href="https://www.youtube.com/watch?v=QBu2Ae8-8LM">this wide ranging Dick Sites talk</a> which covers, among other things, <a href="http://www.pdl.cmu.edu/SDI/2015/slides/DatacenterComputers.pdf">the performance tracing framework that Dick and others have created at Google</a>. By capturing “every” event that happens, it lets us easily debug performance oddities that would otherwise be difficult to track down. We&#39;ll take a look at three different bugs to get an idea about the kinds of problems Google&#39;s tracing framework is useful for.</p> <p>First, we can look at another view of the search query we just saw above: given a top-level query that issues some number of RPCs, how long does it take to get responses?</p> <p><img src="https://danluu.com/images/perf-tracing/1_93.png" width="596" height="370"/></p> <p>Time goes from left to right. Each row is one RPC, with the blue bar showing when the RPC was issued and when it finished. We can see that the first RPC is issued and returns before 93 other RPCs go out. When the last of those 93 RPCs is done, the search result is returned. We can see that two of the RPCs take substantially longer than the rest; the slowest RPC gates the result of the search query.</p> <p>To debug this problem, we want a couple things. Because the vast majority of RPCs in a slow query are normal, and only a couple are slow, we need something that does more than just show aggregates, like a sampling profiler would. We need something that will show us specifically what&#39;s going on in the slow RPCs. Furthermore, because weird performance events may be hard to reproduce, we want something that&#39;s cheap enough that we can run it all the time, allowing us to look at any particular case of bad performance in retrospect. In the talk, Dick Sites mentions having a budget of about 1% of CPU for the tracing framework they have.</p> <p>In addition, we want a tool that has time-granularity that&#39;s much shorter than the granularity of the thing we&#39;re debugging. Sampling profilers typically run at something like 1 kHz (1 ms between samples), which gives little insight into what happens in a one-time event, like an slow RPC that still executes in under 1ms. There are tools that will display what looks like a trace from the output of a sampling profiler, but the resolution is so poor that these tools provide no insight into most performance problems. While it&#39;s possible to crank up the sampling rate on something like perf, you can&#39;t get as much resolution as we need for the problems we&#39;re going to look at.</p> <p>Getting back to the framework, to debug something like this, we might want to look at a much more zoomed in view. Here&#39;s an example with not much going on (just tcpdump and some packet processing with <a href="http://linux.die.net/man/2/recvmsg">recvmsg</a>), just to illustrate what we can see when we zoom in.</p> <p><img src="https://danluu.com/images/perf-tracing/tcpdump.png" width="756" height="369"/></p> <p>The horizontal axis is time, and each row shows what a CPU is executing. The different colors indicate that different things are running. The really tall slices are kernel mode execution, the thin black line is the idle process, and the medium height slices are user mode execution. We can see that CPU0 is mostly handling incoming network traffic in a user mode process, with 18 switches into kernel mode. CPU1 is maybe half idle, with a lot of jumps into kernel mode, doing interrupt processing for tcpdump. CPU2 is almost totally idle, except for a brief chunk when a timer interrupt fires.</p> <p>What&#39;s happening is that every time a packet comes in, an interrupt is triggered to notify tcpdump about the packet. The packet is then delivered to the process that called <code>recvmsg</code> on CPU0. Note that running tcpdump isn&#39;t cheap, and it actually consumes 7% of a server if you turn it on when the server is running at full load. This only dumps network traffic, and it&#39;s already at 7x the budget we have for tracing everything! If we were to look at this in detail, we&#39;d see that Linux&#39;s TCP/IP stack has a large instruction footprint, and workloads like tcpdump will consistently come in and wipe that out of the l1i and l2 caches.</p> <p>Anyway, now that we&#39;ve seen a simple example of what it looks like when we zoom in on a trace, let&#39;s look at how we can debug the slow RPC we were looking at before.</p> <p><img src="https://danluu.com/images/perf-tracing/CPU_RPC_view.png" width="832" height="534"/></p> <p>We have two views of a trace of one machine here. At the top, there&#39;s one row per CPU, and at the bottom there&#39;s one row per RPC. Looking at the top set, we can see that there are some bits where individual CPUs are idle, but that the CPUs are mostly quite busy. Looking at the bottom set, we can see parts of 40 different searches, most of which take around 50us, with the exception of a few that take much longer, like the one pinned between the red arrows.</p> <p><img src="https://danluu.com/images/perf-tracing/LOCK_THREAD_view.png" width="816" height="552"/></p> <p>We can also look at a trace of the same timeframe by which locks are behind held and which threads are executing. The arcs between the threads and the locks show when a particular thread is blocked, waiting on a particular lock. If we look at this, we can see that the time spent waiting for locks is sometimes much longer than the time spent actually executing anything. The thread pinned between the arrows is the same thread that&#39;s executing that slow RPC. It&#39;s a little hard to see what&#39;s going on here, so let&#39;s focus on that single slow RPC.</p> <p><img src="https://danluu.com/images/perf-tracing/CPU_RPC_zoom.png" width="856" height="538"/></p> <p>We can see that this RPC spends very little time executing and a lot of time waiting. We can also see that we&#39;d have a pretty hard time trying to find the cause of the waiting with traditional performance measurement tools. <a href="http://stackoverflow.com/questions/24021967/finding-performance-issue-that-may-be-due-to-thread-locking-possibly">According to stackoverflow, you should use a sampling profiler</a>! But tools like OProfile are useless since they&#39;ll only tell us what&#39;s going on when our RPC is actively executing. What we really care about is what our thread is blocked on and why.</p> <p>Instead of following the advice from stackoverflow, let&#39;s look at the second view of this again.</p> <p><img src="https://danluu.com/images/perf-tracing/LOCK_THREAD_iso.png" width="802" height="536"/></p> <p>We can see that, not only is this RPC spending most of its time waiting for locks, it&#39;s actually spending most of its time waiting for the same lock, with only a short chunk of execution time between the waiting. With this, we can look at the cause of the long wait for a lock. Additionally, if we zoom in on the period between waiting for the two locks, we can see something curious.</p> <p><img src="https://danluu.com/images/perf-tracing/super_zoom.png" width="705" height="438"/></p> <p>It takes 50us for the thread to start executing after it gets scheduled. Note that the wait time is substantially longer than the execution time. The waiting is because <a href="http://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/">an affinity policy was set which will cause the scheduler to try to schedule the thread back to the same core</a> so that any data that&#39;s in the core&#39;s cache will still be there, giving you the best possible cache locality, which means that the thread will have to wait until the previously scheduled thread finishes. That makes intuitive sense, but if consider, for example, a <a href="http://users.atw.hu/instlatx64/GenuineIntel00506E3_Skylake_NewMemLat.txt">2.2GHz Skylake</a>, the cache latency is 6.4ns, and 21.2ns to l2, and l3 cache, respectively. Is it worth changing the affinity policy to speed this kind of thing up? You can&#39;t tell from this single trace, but with the tracing framework used to generate this data, you could do the math to figure out if you should change the policy.</p> <p>In the talk, Dick notes that, given the actual working set size, it would be worth waiting up to 10us to schedule on another CPU sharing the same l2 cache, and 100us to schedule on another CPU sharing the same l3 cache.</p> <p>Something else you can observe from this trace is that, if you care about a workload that resembles Google search, basically every standard benchmark out there is bad, and the standard technique of running <a href="https://danluu.com/intel-cat/#spec">N copies of spec</a> is terrible. That&#39;s not a straw man. People still do that in academic papers today, and some chip companies use SPEC to benchmark their mobile devices!</p> <p>Anyway, that was one performance issue where we were able to see what was going on because of the ability to see a number of different things at the same time (CPU scheduling, thread scheduling, and locks). Let&#39;s look at a simpler single-threaded example on a single machine where a tracing framework is still beneficial:</p> <p><img src="https://danluu.com/images/perf-tracing/gmail.png" width="906" height="515"/></p> <p>This is a trace from gmail, circa 2004. Each row shows the processing that it takes to handle one email. Well, except for the last 5 rows; the last email shown takes so long to process that displaying all of the processing takes 5 rows of space. If we look at each of the normal emails, they all look approximately the same in terms of what colors (i.e., what functions) are called and how much time they take. The last one is different. It starts the same as all the others, but then all this other junk appears that only happens in the slow email.</p> <p>The email itself isn&#39;t the problem -- all of that extra junk is the processing that&#39;s done to reindex the words from the emails that had just come in, which was batched up across multiple emails. This picture caused the Gmail devs to move that batch work to another thread, reducing tail latency from 1800ms to 100ms. This is another performance bug that it would be very difficult to track down with standard profiling tools. I&#39;ve often wondered why email almost always appears quickly when I send to gmail from gmail, and it sometimes takes minutes when I send work email from outlook to outlook. My guess is that a major cause is that it&#39;s much harder for the outlook devs to track down tail latency bugs like this than it is for the gmail devs to do the same thing.</p> <p>Let&#39;s look at one last performance bug before moving on to discussing what kind of visibility we need to track these down. This is a bit of a spoiler, but with this bug, it&#39;s going to be critical to see what the entire machine is doing at any given time.</p>  <p><img src="https://danluu.com/images/perf-tracing/disk_tail.png" width="765" height="501"/></p> <p>This is a histogram of disk latencies on storage machines for a 64kB read, in ms. There are two sets of peaks in this graph. The ones that make sense, on the left in blue, and the ones that don&#39;t, on the right in red.</p> <p>Going from left to right on the peaks that make sense, first there&#39;s the peak at 0ms for things that are cached in RAM. Next, there&#39;s a peak at 3ms. That&#39;s way too fast for the 7200rpm disks we have to transfer 64kB; the time to get a random point under the head is already <code>(1/(7200/60)) / 2 s = 4ms</code>. That must be the time it takes to transfer something from the disk&#39;s cache over PCIe. The next peak, at near 25ms, is the time it takes to seek to a point and then read 64kB off the disk.</p> <p>Those numbers don&#39;t look so bad, but the 99%-ile latency is a whopping 696ms, and there are peaks at 250ms, 500ms, 750ms, 1000ms, etc. And these are all unreproducible -- if you go back and read a slow block again, or even replay the same sequence of reads, the slow reads are (usually) fast. That&#39;s weird! What could possibly cause delays that long? In the talk, Dick Sites says “each of you think of a guess, and you&#39;ll find you&#39;re all wrong”.</p> <p><img src="https://danluu.com/images/perf-tracing/13disks.png" width="852" height="150"/></p> <p>That&#39;s a trace of thirteen disks in a machine. The blue blocks are reads, and the red blocks are writes. The black lines show the time from the initiation of a transaction by the CPU until the transaction is completed. There are some black lines without blocks because some of the transactions hit in a cache and don&#39;t require actual disk activity. If we wait for a period where we can see tail latency and zoom in a bit, we&#39;ll see this:</p> <p><img src="https://danluu.com/images/perf-tracing/13disks_tail.png" width="902" height="319"/></p> <p>We can see that there&#39;s a period where things are normal, and then some kind of phase transition into a period where there are 250ms gaps (4) between periods of disk activity (5) on the machine <em>for all disks</em>. This goes on for nine minutes. And then there&#39;s a phase transition and disk latencies go back to normal. That it&#39;s machine wide and not disk specific is a huge clue.</p> <p>Using that information, Dick pinged various folks about what could possibly cause periodic delays that are a multiple of 250ms on an entire machine, and found out that the cause was kernel throttling of the CPU for processes that went beyond their usage quota. To enforce the quota, the kernel puts all of the relevant threads to sleep until the next multiple of a quarter second. When the quarter-second hand of the clock rolls around, it wakes up all the threads, and if those threads are still using too much CPU, the threads get put back to sleep for another quarter second. The phase change out of this mode happens when, by happenstance, there aren&#39;t too many requests in a quarter second interval and the kernel stops throttling the threads.</p> <p>After finding the cause, an engineer found that this was happening on 25% of disk servers at Google, for an average of half an hour a day, with periods of high latency as long as 23 hours. This had been happening for three years. Dick Sites says that fixing this bug paid for his salary for a decade. This is another bug where traditional sampling profilers would have had a hard time. The key insight was that the slowdowns were correlated and machine wide, which isn&#39;t something you can see in a profile.</p> <p>One question you might have is, is this because of some flaw in existing profilers, or can profilers provide enough information that you don&#39;t need to use tracing tools to track down rare, long-tail, performance bugs? I&#39;ve been talking to Xi Yang about this, who had an ISCA 2015 <a href="http://research.microsoft.com/pubs/244803/preprint.pdf">paper</a> and <a href="https://github.com/yangxi/papers/blob/master/SHIM-ISCA-slides.pptx">talk</a> describing some of his work. He and his collaborators have done a lot more since publishing the paper, but the paper still contains great information on how far a profiling tool can be pushed. As Xi explains in his talk, one of the fundamental limits of a sampling profiler is how often you can sample.</p> <p><img src="https://danluu.com/images/perf-tracing/perf_sample_1k_100k_10m.png" width="616" height="424"/></p> <p>This is a graph of the number of the number of executed instructions per clock (IPC) over time in <a href="https://en.wikipedia.org/wiki/Lucene">Lucene</a>, which is the core of Elasticsearch.</p> <p>At 1kHz, which is the default sampling interval for perf, you basically can&#39;t see that anything changes over time at all. At 100kHz, which is as fast as perf runs, you can tell something is going on, but not what. The 10MHz graph is labeled SHIM because that&#39;s the name of the tool presented in the paper. At 10MHz, you get a much better picture of what&#39;s going on (although it&#39;s worth noting that 10MHz is substantially lower resolution than you can get out of some tracing frameworks).</p> <p>If we look at the IPC in different methods, we can see that we&#39;re losing a lot of information at the slower sampling rates:</p> <p><img src="https://danluu.com/images/perf-tracing/perf_top_10_methods.png" width="813" height="372"/></p> <p>This is the top 10 hottest methods Lucene ranked by execution time; these 10 methods account for 74% of the total execution time. With perf, it&#39;s hard to tell which methods have low IPC, i.e., which methods are spending time stalled. But with SHIM, we can clearly see that there&#39;s one method that spends a lot of time waiting, #4.</p> <p>In retrospect, there&#39;s nothing surprising about these graphs. We know from the Nyquist theorem that, <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">to observe a signal with some frequency, X, we have to sample with a rate at least 2X</a>. There are a lot of factors of performance that have a frequency higher than 1kHz (e.g., <a href="https://software.intel.com/en-us/articles/power-management-states-p-states-c-states-and-package-c-states">CPU p-state changes</a>), so we should expect that we&#39;re unable to directly observe a lot of things that affect performance with perf or other traditional sampling profilers. If we care about microbenchmarks, we can get around this by repeatedly sampling the same thing over and over again, but for rare or one-off events, it may be hard or impossible to do that.</p> <p>This raises a few questions:</p> <ol> <li>Why does perf sample so infrequently?</li> <li>How does SHIM get around the limitations of perf?</li> <li>Why are sampling profilers dominant?</li> </ol> <h4 id="1-why-does-perf-sample-so-infrequently">1. Why does perf sample so infrequently?</h4> <p>This comment from <a href="https://github.com/torvalds/linux/blob/7b648018f628eee73450b71dc68ebb3c3865465e/kernel/events/core.c#L274">events/core.c in the linux kernel</a> explains the limit:</p> <blockquote> <p>perf samples are done in some very critical code paths (<a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">NMIs</a>). If they get too much CPU time, the system can lock up and not get any real work done.</p> </blockquote> <p>As we saw from the tcpdump trace in the Dick Sites talk, interrupts take a significant amount of time to get processed, which limits the rate at which you can sample with an interrupt based sampling mechanism.</p> <h4 id="2-how-does-shim-get-around-the-limitations-of-perf">2. How does SHIM get around the limitations of perf?</h4> <p>Instead of having an interrupt come in periodically, like perf, SHIM instruments the runtime so that it periodically runs a code snippet that can squirrel away relevant information. In particular, the authors instrumented the Jikes RVM, which injects yield points into every method prologue, method epilogue, and loop back edge. At a high level, injecting a code snippet into every function prologue and epilogue sounds similar to what Dick Sites describes in his talk.</p> <p>The details are different, and I recommend both watching the Dick Sites talk and reading the Yang et al. paper if you&#39;re interested in performance measurement, but the fundamental similarity is that both of them decided that it&#39;s <a href="https://danluu.com/new-cpu-features/#context-switches-syscalls">too expensive to having another thread break in and sample periodically</a>, so they both ended up injecting some kind of tracing code into the normal execution stream.</p> <p>It&#39;s worth noting that sampling, at any frequency, is going to miss waiting on (for example) software locks. Dick Sites&#39;s recommendation for this is to timestamp based on wall clock (not CPU clock), and then try to find the underlying causes of unusually long waits.</p> <h4 id="3-why-are-sampling-profilers-dominant">3. Why are sampling profilers dominant?</h4> <p>We&#39;ve seen that Google&#39;s tracing framework allows us to debug performance problems that we&#39;d never be able to catch with traditional sampling profilers, while also collecting the data that sampling profilers collect. From the outside, SHIM looks like a high-frequency sampling profiler, but it does so by acting like a tracing tool. Even perf is getting support for low-overhead tracing. Intel added <a href="https://software.intel.com/en-us/blogs/2013/09/18/processor-tracing">hardware support for certain types for certain types of tracing in Broadwell and Skylake</a>, along with kernel support in 4.1 (with user mode support for perf coming in 4.3). If you&#39;re wondering how much overhead these tools have, Andi Kleen claims that the Intel tracing support in Linux has about a 5% overhead, and Dick Sites mentions in the talk that they have a budget of about 1% overhead.</p> <p>It&#39;s clear that state-of-the-art profilers are going to look a lot like tracing tools in the future, but if we look at the state of things today, the easiest options are all classical profilers. You can fire up a profiler like perf and it will tell you approximately how much time various methods are taking. With other basic tooling, you can tell what&#39;s consuming memory. Between those two numbers, you can solve the majority of performance issues. Building out something like Google&#39;s performance tracing framework is non-trivial, and cobbling together existing publicly available tools to trace performance problems is a rough experience. You can see one example of this when <a href="https://blog.cloudflare.com/the-story-of-one-latency-spike/">Marek Majkowski debugged a tail latency issue using System Tap</a>.</p> <p>In <a href="http://www.brendangregg.com/blog/2015-07-08/choosing-a-linux-tracer.html">Brendan Gregg&#39;s page on Linux tracers</a>, he says “[perf_events] can do many things, but if I had to recommend you learn just one [tool], it would be CPU profiling”. Tracing tools are cumbersome enough that his top recommendation on his page about tracing tools is to learn a profiling tool!</p> <h3 id="now-what">Now what?</h3> <p>If you want to use an tracing tool like the one we looked at today your options are:</p> <ol> <li>Get a job at <a href="https://danluu.com/startup-tradeoffs/">Google</a></li> <li>Build it yourself</li> <li>Cobble together what you need out of existing tools</li> </ol> <h4 id="1-get-a-job-at-google-danluu-com-startup-tradeoffs">1. Get a job at <a href="https://danluu.com/startup-tradeoffs/">Google</a></h4> <p>I hear <a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html">Steve Yegge has good advice on how to do this</a>. If you go this route, try to attend orientation in Mountain View. They have the best orientation.</p> <h4 id="2-build-it-yourself">2. Build it yourself</h4> <p>If you look at <a href="http://research.microsoft.com/pubs/244803/preprint.pdf">the SHIM paper</a>, there&#39;s a lot of cleverness built-in to get really fine-grained information while minimizing overhead. I think their approach is really neat, but considering the current state of things, you can get a pretty substantial improvement without much cleverness. Fundamentally, all you really need is some way to inject your tracing code at the appropriate points, some number of bits for a timestamp, plus a handful of bits to store the event.</p> <p>Say you want trace transitions between user mode and kernel mode. The transitions between waiting and running will tell you what the thread was waiting on (e.g., disk, timer, IPI, etc.). There are maybe 200k transitions per second per core on a busy node. 200k events with a 1% overhead is 50ns per event per core. A cache miss is well over 100 cycles, so our budget is less than one cache miss per event, meaning that each record must fit within a fraction of a cache line. If we have 20 bits of timestamp (<code>RDTSC &gt;&gt; 8 bits</code>, giving ~100ns resolution and 100ms range) and 12 bits of event, that&#39;s 4 bytes, or 16 events per cache line. Each core has to have its own buffer to avoid cache contention. To map <code>RDTSC</code> times back to wall clock times, calling <code>gettimeofday</code> along with <code>RDTSC</code> at least every 100ms is sufficient.</p> <p>Now, say the machine is serving 2000 QPS. That&#39;s 20 99%-ile tail events per second and 2 99.9% tail events per second. Since those events are, by definition, unusually long, Dick Sites recommends a window of 30s to 120s to catch those events. If we have 4 bytes per event * 200k events per second * 40 cores, that&#39;s about 32MB/s of data. Writing to disk while we&#39;re logging is hopeless, so you&#39;ll want to store the entire log while tracing, which will be in the range of 1GB to 4GB. That&#39;s probably fine for a typical machine in a datacenter, which will have between 128GB and 256GB of RAM.</p> <p>My not-so-secret secret hope for this post is that someone will take this idea and implement it. That&#39;s already happened with at least one blog post idea I&#39;ve thrown out there, and this seems at least as valuable.</p> <h4 id="3-cobble-together-what-you-need-out-of-existing-tools">3. Cobble together what you need out of existing tools</h4> <p>If you don&#39;t have a magical framework that solves all your problems, the tool you want is going to depend on the problem you&#39;re trying to solve.</p> <p>For figuring out why things are waiting, Brendan Gregg&#39;s write-up on <a href="http://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html">off-CPU flame graphs is a pretty good start</a> if you don&#39;t have access to internal Google tools. For that matter, <a href="http://www.brendangregg.com/linuxperf.html">his entire site</a> is great if you&#39;re doing any kind of Linux performance analysis. There&#39;s info on Dtrace, ftrace, SystemTap, etc. Most tools you might use are covered, although <a href="https://github.com/jcsaezal/pmctrack">PMCTrack</a> is missing.</p> <p>The problem with all of these is that they&#39;re all much higher overhead than the things we&#39;ve looked at today, so they can&#39;t be run in the background to catch and effectively replay any bug that comes along if you operate at scale. Yes, that includes dtrace, which I&#39;m calling out in particular because any time you have one of these discussions, a dtrace troll will come along to say that dtrace has supported that for years. It&#39;s like the common lisp of trace tools, in terms of community trolling.</p> <p>Anyway, if you&#39;re on Windows, <a href="https://randomascii.wordpress.com/2015/04/14/uiforetw-windows-performance-made-easier/">Bruce Dawson&#39;s site</a> seems to be the closest analogue to Bredan Gregg&#39;s site. If that doesn&#39;t have enough detail, <a href="https://www.amazon.com/gp/product/0735684189/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=abroaview-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0735684189&amp;linkId=3119782cd4e0ad47568c854ed17b219f">there&#39;s always the Windows Internals books</a>.</p> <p>This is a bit far afield, but for problems where you want an easy way to get CPU performance counters, <a href="https://github.com/RRZE-HPC/likwid">likwid</a> is nice. It has a much nicer interface than <code>perf stat</code>, lets you easily only get stats for selected functions, etc.</p> <p><small> Thanks to Nathan Kurz, Xi Yang, Leah Hanson, John Gossman, Dick Sites, Hari Angepat, and Dan Puttick for comments/corrections/discussion.</small></p> <p>P.S. Xi Yang, one of the authors of SHIM is finishing up his PhD soon and is going to be looking for work. If you want to hire a performance wizard, <a href="https://yangxi.github.io/">he has a CV and resume here</a>. </p>  </div></div>
        </section>
    </article>
</main>
</body>
</html>
