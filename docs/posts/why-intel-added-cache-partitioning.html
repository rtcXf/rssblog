<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Why Intel added cache partitioning | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/intel-cat/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Why Intel added cache partitioning</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p><a href="http://csl.stanford.edu/~christos/publications/2015.heracles.isca.pdf">Typical server utilization is between 10% and 50%. Google has demonstrated 90% utilization <em>without impacting latency SLAs</em></a>. <a href="https://what-if.xkcd.com/63/">Xkcd estimated that Google owns 2 million machines</a>. If you estimate an amortized total cost of <a href="http://www.morganclaypool.com/doi/pdf/10.2200/S00516ED2V01Y201306CAC024">$4k per machine per year</a>, that&#39;s $8 billion per year. With numbers like that, even small improvements have a large impact, and this isn&#39;t a small improvement.</p>  <p>How is it possible to get 2x to 9x better utilization on the same hardware? The low end of those typical utilization numbers comes from having a service with variable demand and fixed machine allocations. Say you have 100 machines dedicated to Jenkins. Those machines might be very busy when devs are active, but they might also have 2% utilization at 3am. Dynamic allocation (switching the machines to other work when they&#39;re not needed) can get a typical latency-sensitive service up to somewhere in the 30%-70% range. To do better than that across a wide variety of latency-sensitive workloads with tight SLAs, we need some way to schedule low priority work on the same machines, without affecting the latency of the high priority work.</p> <p>It&#39;s not obvious that this is possible. If both high and low priority workloads need to monopolize some shared resources like the last-level cache (LLC), memory bandwidth, disk bandwidth, or network bandwidth, there we&#39;re out of luck. With the exception of some specialized services, it&#39;s rare to max out disk or network. But what about caches and memory? It turns out that <a href="http://www.industry-academia.org/download/ASPLOS12_Clearing_the_Clouds.pdf">Ferdman et al.</a> looked at this back in 2012 and found that typical server workloads don&#39;t benefit from having more than 4MB - 6MB of LLC, despite modern server chips having much larger caches.</p> <p><img src="https://danluu.com/images/intel-cat/server_llc.png" width="321" height="208"/></p> <p>For this graph, scale-out workloads are things like distributed key-value stores, MapReduce-like computations, web search, web serving, etc. SPECint(mcf) is a traditional workstation benchmark. “server” is old school server benchmarks like SPECweb and TPC . We can see that going from 4MB to 11MB of LLC has a small effect on typical datacenter workloads, but a significant effect on this traditional workstation benchmark.</p> <p>Datacenter workloads operate on such large data sets that it&#39;s often impossible to fit the dataset in RAM on a single machine, let alone in cache, making a larger LLC not particularly useful. This was result was confirmed by <a href="http://www.eecs.harvard.edu/~skanev/papers/isca15wsc.pdf">Kanev et al.&#39;s ISCA 2015 paper where they looked at workloads at Google</a>. They also showed that memory bandwidth utilization is, on average, quite low.</p> <p><img src="https://danluu.com/images/intel-cat/low_bandwidth_utilization.png" width="342" height="175"/></p> <p>You might think that the low bandwidth utilization is because the workloads are compute bound and don&#39;t have many memory accesses. However, when the authors looked at what the cores were doing, they found that a lot of time was spent stalled, waiting for cache/memory.</p> <p><img src="https://danluu.com/images/intel-cat/cache_stalls.png" width="328" height="169"/></p> <p>Each row is a Google workload. When running these typical workloads, cores spend somewhere between 46% and 61% of their time blocked on cache/memory. It&#39;s curious that we have low cache hit rates, a lot of time stalled on cache/memory, and low bandwidth utilization. This is suggestive of workloads spending a lot of time waiting on memory accesses that have some kind of dependencies that prevent them from being executed independently.</p> <p>LLCs for high-end server chips are between 12MB and 30MB, even though we only need 4MB to get 90% of the performance, and the 90%-ile utilization of bandwidth is 31%. This seems like a waste of resources. We have a lot of resources sitting idle, or not being used effectively. The good news is that, since we get such low utilization out of the shared resources on our chips, we should be able to schedule multiple tasks on one machine without degrading performance.</p> <p>Great! What happens when we schedule multiple tasks on one machine? The <a href="http://csl.stanford.edu/~christos/publications/2015.heracles.isca.pdf">Lo et al. Heracles paper at ISCA this year explores this in great detail</a>. The goal of Heracles is to get better utilization on machines by co-locating multiple tasks on the same machine.</p> <p><img src="https://danluu.com/images/intel-cat/heracles_interference.png" width="665" height="343"/></p> <p>The figure above shows three latency sensitive (LC) workloads with strict SLAs. websearch is the query serving service in Google search, ml_cluster is real-time text clustering, and memkeyval is a key-value store analogous to memcached. The values are latencies as a percent of maximum allowed by the SLA. The columns indicate the load on the service, and the rows indicate different types of interference. LLC, DRAM, and Network are exactly what they sound like; custom tasks designed to compete only for that resource. HyperThread means that the interfering task is a spinloop running in the other hyperthread on the same core (running in the same hyperthread isn&#39;t even considered since OS context switches are too expensive). CPU power is a task that&#39;s designed to use a lot of power and induce thermal throttling. Brain is deep learning. All of the interference tasks are run in a container with low priority.</p> <p>There&#39;s a lot going on in this figure, but we can immediately see that the best effort (BE) task we&#39;d like to schedule can&#39;t co-exist with any of the LC tasks when only container priorities are used -- all of the <code>brain</code> rows are red, and even at low utilization (the leftmost columns), latency is way above 100% of the SLA latency.. It&#39;s also clear that the different LC tasks have different profiles and can handle different types of interference. For example, websearch and ml_cluster are neither network nor compute intensive, so they can handle network and power interference well. However, since memkeyval is both network and compute intensive, it can&#39;t handle either network or power interference. The paper goes into a lot more detail about what you can infer from the details of the table. I find this to be one of the most interesting parts of the paper; I&#39;m going to skip over it, but I recommend reading the paper if you&#39;re interested in this kind of thing.</p> <p>A simplifying assumption the authors make is that these types of interference are basically independent. This means that independent mechanisms that isolate LC task from “too much” of each individual type of resource should be sufficient to prevent overall interference. That is, we can set some cap for each type of resource usage, and just stay below each cap. However, this assumption isn&#39;t exactly true -- for example, the authors show this figure that relates the LLC cache size to the number cores allocated to an LC task.</p> <p><img src="https://danluu.com/images/intel-cat/llc_vs_cores.png" width="277" height="238"/></p> <p>The vertical axis is the max load the LC task can handle before violating its SLA when allocated some specific LLC and number of cores. We can see that it&#39;s possible to trade off cache vs cores, which means that we can actually go above a resource cap in one dimension and maintain our SLA by using less of another resource. In the general case, we might also be able to trade off other resources. However, the assumption that we can deal with each resource independently reduces a complex optimization problem to something that&#39;s relatively straightforward.</p> <p>Now, let&#39;s look at each type of shared resource interference and how Heracles allocates resources to prevent SLA-violating interference.</p> <h4 id="core">Core</h4> <p>Pinning the LC and BE tasks to different cores is sufficient to prevent same-core context switching interference and hyperthreading interference. For this, Heracles used <a href="https://www.kernel.org/doc/Documentation/cgroups/cpusets.txt">cpuset</a>. Cpuset allows you to limit a process (and its children) to only run on a limited set of CPUs.</p> <h4 id="network">Network</h4> <p>On the local machines, Heracles used <a href="https://wiki.archlinux.org/index.php/Advanced_traffic_control">qdisc</a> to enforce quotas. For more on cpuset, qdisc, and other quota/partitioning mechanisms <a href="https://lwn.net/Articles/604609/">this LWN series on cgroups by Neil Brown is a good place to start</a>. Cgroups are used by a lot of widely used software now (Docker, Kubernetes, Mesos, etc.); they&#39;re probably worth learning about even if you don&#39;t care about this particular application.</p> <h4 id="power">Power</h4> <p>Heracles uses <a href="https://01.org/blogs/tlcounts/2014/running-average-power-limit-%E2%80%93-rapl">Intel&#39;s running average power limit</a> to estimate power. This is a feature on Sandy Bridge (2009) and newer processors that uses some on-chip monitoring hardware to estimate power usage fairly precisely. <a href="http://www.cs.binghamton.edu/~millerti/cs680r/papers/DVFS/SystemLevelAnalysis.pdf">Per-core dynamic voltage and frequency scaling</a> is used to limit power usage by specific cores to keep them from going over budget.</p> <h4 id="cache">Cache</h4> <p>The previous isolation mechanisms have been around for a while, but this is one is new to Broadwell chips (released in 2015). The problem here is that if the BE task needs 1MB of LLC and the LC task needs 4MB of LLC, a single large allocation from the BE task will scribble all over the LLC, which is shared, wiping out the 4MB of cached data the LC needs.</p> <p>Intel&#39;s “<a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3b-part-2-manual.pdf">Cache Allocation Technology</a>” (CAT) allows the LLC to limit which cores can can access different parts of the cache. Since we often want to pin performance sensitive tasks to cores anyway, this allows us to divide up the cache on a per-task basis.</p> <p><img src="https://danluu.com/images/intel-cat/CAT_LLC.png" width="431" height="157"/></p> <p>Intel&#39;s <a href="http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/cache-allocation-technology-white-paper.pdf">April 2015 whitepaper on what they call Cache Allocation Technology (CAT)</a> has some simple benchmarks comparing CAT vs. no-CAT. In this example, they measure the latency to respond to PCIe interrupts while another application has heavy CPU-to-memory traffic, with CAT on and off.</p> <table> <thead> <tr> <th>Condition</th> <th>Min</th> <th>Max</th> <th>Avg</th> </tr> </thead> <tbody> <tr> <td>no CAT</td> <td>1.66</td> <td>30.91</td> <td>4.53</td> </tr> <tr> <td>CAT</td> <td>1.22</td> <td>20.98</td> <td>1.62</td> </tr> </tbody> </table> <p>With CAT, average latency is 36% of latency without CAT. Tail latency doesn&#39;t improve as much, but there&#39;s also a substantial improvement there. That&#39;s interesting, but to me the more interesting question is how effective this is on real workloads, which we&#39;ll see when we put all of these mechanisms together.</p> <p>Another use of CAT that I&#39;m not going to discuss at all is to prevent timing attacks, like <a href="https://eprint.iacr.org/2015/898.pdf">this attack, which can recover RSA keys across VMs via LLC interference</a>.</p> <h4 id="dram-bandwidth">DRAM bandwidth</h4> <p>Broadwell and newer Intel chips have memory bandwidth monitoring, but no control mechanism. To work around this, Heracles drops the number of cores allocated to the BE task if it&#39;s interfering with the LC task by using too much bandwidth. The coarse grained monitoring and control for this is inefficient in a number of ways that are detailed in the paper, but this still works despite the inefficiencies. However, having per-core bandwidth limiting would give better results with less effort.</p> <h4 id="putting-it-all-together">Putting it all together</h4> <p>This graph shows the effective utilization of LC websearch with other BE tasks scheduled with enough slack that the SLA for websearch isn&#39;t violated.</p> <p><img src="https://danluu.com/images/new-cpu-features/google_heracles.png" width="338" height="209"/></p> <p>From barroom conversations with folks at other companies, the baseline (in red) here already looks pretty good: 80% utilization during peak times with a 7 hour trough when utilization is below 50%. With Heracles, the <em>worst case</em> utilization is 80%, and the average is 90%. This is amazing.</p> <p>Note that effective utilization can be greater than 100% since it&#39;s measured as throughput for the LC task on a single machine at 100% load plus throughput for the BE task on a single machine at 100% load. For example, if one task needs 100% of the DRAM bandwidth and 0% of the network bandwidth, and the other task needs the opposite, the two tasks would be able to co-locate on the same machine and achieve 200% effective utilization.</p> <p>In the real world, we might “only” get 90% average utilization out of a system like Heracles. Recalling our operating cost estimate of $4 billion for a large company, if the company already had a quite-good average utilization of 75%, using <a href="http://www.morganclaypool.com/doi/pdf/10.2200/S00516ED2V01Y201306CAC024">a standard model for datacenter operating costs</a>, we&#39;d expect 15% more throughput per dollar, or $600 million in free compute. From talking to smaller companies that are on their way to becoming large (companies that spend in the range of $10 million to $100 million a year on compute), they often have utilization that&#39;s in the 20% range. Using the same total cost model again, they&#39;d expect to get a 300% increase in compute per dollar, or $30 million to $300 million a year in free compute, depending on their size.</p> <h4 id="other-observations">Other observations</h4> <p>All of the papers we&#39;ve looked at have a lot of interesting gems. I&#39;m not going to go into all of them here, but there are a few that jumped out at me.</p> <h5 id="arm-atom-servers">ARM / Atom servers</h5> <p>It&#39;s been known for a long time that datacenter machines spend approximately half their time stalled, waiting on memory. In addition, the average number of instructions per clock that server chips are able to execute on real workloads is quite low.</p> <p><img src="https://danluu.com/images/intel-cat/server_ipc.png" width="335" height="207"/></p> <p>The top rows (with horizontal bars) are internal Google workloads and the bottom rows (with green dots) are workstation benchmarks from SPEC, a standard benchmark suite. We can see that Google workloads are lucky to average .5 instructions per clock. We also previously saw that these workloads cause cores to be stalled on memory at least half the time.</p> <p>Despite spending most of their time waiting for memory and averaging something like half an instruction per clock cycle, high-end server chips do much better than Atom or ARM chips on real workloads (Reddi et al., ToCS 2011). This sounds a bit paradoxical -- if chips are just waiting on memory, why should you need a high-performance chip? A tiny ARM chip can wait just as effectively. In fact, it might even be better at waiting since having <a href="http://yosefk.com/blog/amdahls-law-in-reverse-the-wimpy-core-advantage.html">more cores waiting means it can use more bandwidth</a>. But it turns out that servers also spend a lot of their time exploiting instruction-level parallelism, executing multiple instructions at the same time.</p> <p><img src="https://danluu.com/images/intel-cat/server_ilp.png" width="162" height="154"/></p> <p>This is a graph of how many execution units are busy at the same time. Almost a third of the time is spent with 3+ execution units busy. In between long stalls waiting on memory, high-end chips are able to get more computation done and start waiting for the next stall earlier. Something else that&#39;s curious is that server workloads have much higher instruction cache miss rates than traditional workstation workloads.</p> <h5 id="code-and-data-prioritization-technology">Code and Data Prioritization Technology</h5> <p><img src="https://danluu.com/images/intel-cat/icache_miss.png" width="332" height="191"/></p> <p>Once again, the top rows (with horizontal bars) are internal Google workloads and the bottom rows (with green dots) are workstation benchmarks from SPEC, a standard suite benchmark suite. The authors attribute this increase in instruction misses to two factors. First, that it&#39;s normal to deploy large binaries (100MB) that overwhelm instruction caches. And second, that instructions have to compete with much larger data streams for space in the cache, which causes a lot of instructions to get evicted.</p> <p>In order to address this problem, Intel introduced what they call “Code and Data Prioritization Technology” (CDP). This is an extension of CAT that allows cores to separately limit which subsets of the LLC instructions and data can occupy. Since it&#39;s targeted at the last-level cache, it doesn&#39;t directly address the graph above, which shows L2 cache miss rates. However, the cost of an L2 cache miss that hits in the LLC is something like <a href="http://users.atw.hu/instlatx64/GenuineIntel00306D4_Broadwell2_NewMemLat.txt">26ns on Broadwell vs. 86ns for an L2 miss that also misses the LLC and has to go to main memory</a>, which is a substantial difference.</p> <p>Kanev et al. propose going a step further and having a split icache/dcache hierarchy. This isn&#39;t exactly a radical idea -- l1 caches are already split, so why not everything else? My guess is that Intel and other major chip vendors have simulation results showing that this doesn&#39;t improve performance per dollar, but who knows? Maybe we&#39;ll see split L2 caches soon.</p> <h5 id="spec">SPEC</h5> <p>A more general observation is that SPEC is basically irrelevant as a benchmark now. It&#39;s somewhat dated as a workstation benchmark, and simply completely inappropriate as a benchmark for servers, office machines, gaming machines, dumb terminals, laptops, and mobile devices. The market for which SPEC is designed is getting smaller every year, and SPEC hasn&#39;t even been really representative of that market for at least a decade. And yet, among chip folks, it&#39;s still the most widely used benchmark around.</p> <p><img src="https://danluu.com/images/intel-cat/search_query.png" width="640" height="352"/></p> <p>This is what a search query looks like at Google. A query comes in, a wide fanout set of RPCs are issued to a set of machines (the first row). Each of those machines also does a set of RPCs (the second row), those do more RPCs (the third row), and there&#39;s a fourth row that&#39;s not shown because the graph has so much going on that it looks like noise. This is one quite normal type of workload for a datacenter, and there&#39;s nothing in SPEC that looks like this.</p> <p>There are a lot more fun tidbits in all of these papers, and I recommend reading them if you thought anything in this post was interesting. <strong>If you liked this post, you&#39;ll probably also like <a href="https://www.youtube.com/watch?v=QBu2Ae8-8LM">this talk by Dick Sites on various performance and profiling related topics</a>, <a href="https://danluu.com/clwb-pcommit/">this post on Intel&#39;s new CLWB and PCOMMIT instructions</a>, and <a href="https://danluu.com/new-cpu-features/">this post on other &#34;new&#34; CPU features</a></strong>.</p> <p><small> Thanks to Leah Hanson, David Kanter, Joe Wilder, Nico Erfurth, and Jason Davies for comments/corrections on this. </small></p>  </div></div>
        </section>
    </article>
</main>
</body>
</html>
