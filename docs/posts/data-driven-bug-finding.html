<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Data-driven bug finding | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/bugalytics/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Data-driven bug finding</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p><a href="https://danluu.com/everything-is-broken/">I can&#39;t remember the last time I went a whole day without running into a software bug</a>. For weeks, I couldn&#39;t invite anyone to Facebook events due to a bug that caused the invite button to not display on the invite screen. Google Maps has been giving me illegal and sometimes impossible directions ever since I moved to a small city. And Google Docs regularly hangs when I paste an image in, giving me a busy icon until I delete the image.</p> <p>It&#39;s understandable that bugs escape testing. Testing is hard. Integration testing is harder. End to end testing is even harder. But there&#39;s an easier way. A third of bugs like this – bugs I run into daily – could be found automatically using analytics.</p>  <p>If you think finding bugs with analytics sounds odd, ask a hardware person about performance counters. Whether or not they&#39;re user accessible, every ASIC has analytics to allow designers to figure out what changes need to be made for the next generation chip. Because people look at perf counters anyway, they notice when a <a href="http://acg.cis.upenn.edu/papers/micro05_storeq.pdf">forwarding path</a> never gets used, when <a href="http://infoscience.epfl.ch/record/135571/files/micro01-way.pdf">way prediction</a> has a strange distribution, or when the prefetch buffer never fills up. <a href="https://danluu.com/discontinuities/">Unexpected distributions in analytics</a> are a sign of a misunderstanding, which is often a sign of a bug.</p> <p>Facebook logs all user actions. That can be used to determine user dead ends. Google Maps reroutes after “wrong” turns. That can be used to determine when the wrong turns are the result of bad directions. Google Docs could track all undos. That could be used to determine when users run into misfeatures or bugs.</p> <p>I understand why it might feel weird to borrow hardware practices for software development. For the most part, hardware tools are decades behind software tools. As examples: current hardware tools include simulators on Linux that are only half ported from windows, resulting in some text boxes requiring forward slashes while others require backslashes; libraries that fail to compile with `default_nettype none; and components that come with support engineers because they&#39;re expected to be too buggy to work without full-time people supporting any particular use.</p> <p>But when it comes to testing, hardware is way ahead of software. When I write software, fuzzing is considered a state of the art technique. But in hardware land, fuzzing doesn&#39;t have a special name. It&#39;s just testing, and why should there be a special name for &#34;testing that uses randomness&#34;? That&#39;s like having a name for &#34;testing by running code&#34;. Well over a decade ago, I did <a href="http://en.wikipedia.org/wiki/POWER6">hardware testing</a> via a tool that used constrained randomness on inputs, symbolic execution, with state reduction via structural analysis. For small units, the tool was able to generate a formal proof of correctness. For larger units, the tool automatically generated and used coverage statistics and used them to exhaustively search over as diverse a state space as possible. In the case of a bug, a short, easy to debug, counter example would be produced. And hardware testing tools have gotten a lot better since then.</p> <p>But in software land, I&#39;m lucky if a random project I want to contribute to has tests at all. When tests exist, they&#39;re usually handwritten, with all the limitations that implies. Once in a blue moon, I&#39;m pleasantly surprised to find that a software project uses <a href="http://hackage.haskell.org/package/QuickCheck">a test framework</a> which has 1% of the functionality that was standard a decade ago in chip designs.</p> <p>Considering the relative cost of <a href="https://danluu.com/testing/">hardware bugs vs. software bugs</a>, it&#39;s not too surprising that a lot more effort goes into hardware testing. But here&#39;s a case where there&#39;s almost no extra effort. You&#39;ve already got analytics measuring the conversion rate through all sorts of user funnels. The only new idea here is that clicking on an ad or making a purchase isn&#39;t the only type of conversion you should measure. Following directions at an intersection is a conversion, not deleting an image immediately after pasting it is a conversion, and using a modal dialogue box after opening it up is a conversion.</p> <p>Of course, whether it&#39;s ad click conversion rates or cache hit rates, blindly optimizing a single number will get you into a local optima that will hurt you in the long run, and setting thresholds for conversion rates that should send you an alert is nontrivial. There&#39;s a combinatorially large space of user actions, so it takes judicious use of machine learning to figure out reasonable thresholds. That&#39;s going to cost time and effort. But think of all the effort you put into optimizing clicks. You probably figured out, years ago, <a href="http://www.kalzumeus.com/2009/03/07/how-to-successfully-compete-with-open-source-software/">that replacing boring text with giant pancake buttons gives you 3x the clickthrough rate</a>; you&#39;re now down to optimizing 1% here and 2% there. That&#39;s great, and it&#39;s a sign that you&#39;ve captured all the low hanging fruit. But what do you think the future clickthrough rate is when a user encounters a show-stopping bug that prevents any forward progress on a modal dialogue box?</p> <p>If this sounds like an awful lot of work, find a known bug that you&#39;ve fixed, and grep your logs data for users who ran into that bug. Alienating those users by providing a profoundly broken product is doing a lot more to your clickthrough rate than having a hard to find checkout button, and the exact same process that led you to that gigantic checkout button can solve your other problem, too. Everyone knows that adding 200ms of load time can cause 20% of users to close the window. What do you think the effect of exposing them to a bug that takes 5,000ms of user interaction to fix is?</p> <p>If that&#39;s worth fixing, pull out <a href="https://github.com/twitter/scalding">scalding</a>, <a href="http://research.google.com/pubs/pub36632.html">dremel</a>, <a href="http://cascalog.org/">cascalog</a>, or whatever your favorite data processing tool is. Start looking for user actions that don&#39;t make sense. Start looking for bugs.</p> <p><small> Thanks to Pablo Torres for catching a typo in this post </small></p>  </div></div>
        </section>
    </article>
</main>
</body>
</html>
