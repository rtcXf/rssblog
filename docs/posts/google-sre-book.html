<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Google SRE book | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/google-sre-book/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Google SRE book</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p><a href="https://www.amazon.com/gp/product/149192912X/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=abroaview-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=149192912X&amp;linkId=2a578b357abc8b995368a039dd517601">The book</a> starts with a story about a time Margaret Hamilton brought her young daughter with her to NASA, back in the days of the Apollo program. During a simulation mission, her daughter caused the mission to crash by pressing some keys that caused a prelaunch program to run during the simulated mission. Hamilton submitted a change request to add error checking code to prevent the error from happening again, but the request was rejected because the error case should never happen.</p> <p>On the next mission, Apollo 8, that exact error condition occurred and a potentially fatal problem that could have been prevented with a trivial check took NASA’s engineers 9 hours to resolve.</p> <p><em>This sounds familiar -- I’ve lost track of the number of dev post-mortems that have the same basic structure.</em></p> <p><em>This is an experiment in note-taking for me in two ways. First, I normally take pen and paper notes and then scan them in for posterity. Second, I normally don’t post my notes online, but I’ve been inspired to try this by <a href="http://scattered-thoughts.net/">Jamie Brandon’s notes on books he’s read</a>. My handwritten notes are a series of bullet points, which may not translate well into markdown. One issue is that my markdown renderer doesn’t handle more than one level of nesting, so things will get artificially flattened. There are probably more issues. Let’s find out what they are! In case it&#39;s not obvious, asides from me are in italics.</em></p> <h3 id="chapter-1-introduction">Chapter 1: Introduction</h3> <p><em>Everything in this chapter is covered in much more detail later.</em></p> <p>Two approaches to hiring people to manage system stability:</p> <h4 id="traditional-approach-sysadmins">Traditional approach: sysadmins</h4> <ul> <li>Assemble existing components and deploy to produce a service</li> <li>Respond to events and updates as they occur</li> <li>Grow team to absorb increased work as service grows</li> <li>Pros <ul> <li>Easy to implement because it’s standard</li> <li>Large talent pool to hire from</li> <li>Lots of available software</li> </ul></li> <li>Cons <ul> <li>Manual intervention for change management and event handling causes size of team to scale with load on system</li> <li>Ops is fundamentally at odds with dev, which can cause pathological resistance to changes, which causes similarly pathological response from devs, which reclassify “launches” as “incremental updates”, “flag flips”, etc.</li> </ul></li> </ul> <h4 id="google-s-approach-sres">Google’s approach: SREs</h4> <ul> <li>Have software engineers do operations</li> <li>Candidates should be able to pass or nearly pass normal dev hiring bar, and may have some additional skills that are rare among devs (e.g., L1 - L3 networking or UNIX system internals).</li> <li>Career progress comparable to dev career track</li> <li>Results <ul> <li>SREs would be bored by doing tasks by hand</li> <li>Have the skillset necessary to automate tasks</li> <li>Do the same work as an operations team, but with automation instead of manual labor</li> </ul></li> <li>To avoid manual labor trap that causes team size to scale with service load, Google places a 50% cap on the amount of “ops” work for SREs <ul> <li>Upper bound. Actual amount of ops work is expected to be much lower</li> </ul></li> <li>Pros <ul> <li>Cheaper to scale</li> <li>Circumvents devs/ops split</li> </ul></li> <li>Cons <ul> <li>Hard to hire for</li> <li>May be unorthodox in ways that require management support (e.g., product team may push back against decision to stop releases for the quarter because the error budget is depleted)</li> </ul></li> </ul> <p><em>I don’t really understand how this is an example of circumventing the dev/ops split. I can see how it’s true in one sense, but the example of stopping all releases because an error budget got hit doesn’t seem fundamentally different from the “sysadmin” example where teams push back against launches. It seems that SREs have more political capital to spend and that, in the specific examples given, the SREs might be more reasonable, but there’s no reason to think that sysadmins can’t be reasonable.</em></p> <h4 id="tenets-of-sre">Tenets of SRE</h4> <ul> <li>SRE team responsible for latency, performance, efficiency, change management, monitoring, emergency response, and capacity planning</li> </ul> <h4 id="ensuring-a-durable-focus-on-engineering">Ensuring a durable focus on engineering</h4> <ul> <li>50% ops cap means that extra ops work is redirected to product teams on overflow</li> <li>Provides feedback mechanism to product teams as well as keeps load down</li> <li>Target max 2 events per 8-12 hour on-call shift</li> <li>Postmortems for all serious incidents, even if they didn’t trigger a page</li> <li>Blameless postmortems</li> </ul> <p><em>2 events per shift is the max, but what’s the average? How many on-call events are expected to get sent from the SRE team to the dev team per week?</em></p> <p><em>How do you get from a blameful postmortem culture to a blameless postmortem culture? Now that everyone knows that you should have blameless postmortems, <a href="https://danluu.com/wat/">everyone will claim to do them. Sort of like having good testing and deployment practices</a>. I’ve been lucky to be on an on call rotation that’s never gotten paged, but when I talk to folks who joined recently and are on call, they have not so great stories of finger pointing, trash talk, and blame shifting. The fact that everyone knows you’re supposed to be blameless seems to make it harder to call out blamefulness, not easier.</em></p> <h4 id="move-fast-without-breaking-slo">Move fast without breaking SLO</h4> <ul> <li>Error budget. 100% is the wrong reliability target for basically everything</li> <li>Going from 5 9s to 100% reliability isn’t noticeable to most users and requires tremendous effort</li> <li>Set a goal that acknowledges the trade-off and leaves an error budget</li> <li>Error budget can be spent on anything: launching features, etc.</li> <li>Error budget allows for discussion about how phased rollouts and 1% experiments can maintain tolerable levels of errors</li> <li>Goal of SRE team isn’t “zero outages” -- SRE and product devs are incentive aligned to spend the error budget to get maximum feature velocity</li> </ul> <p><em>It’s not explicitly stated, but for teams that need to “move fast”, consistently coming in way under the error budget could be taken as a sign that the team is spending too much effort on reliability.</em></p> <p><em>I like this idea a lot, but when I discussed this with Jessica Kerr, she pushed back on this idea because maybe you’re just under your error budget because you got lucky and a single really bad event can wipe out your error budget for the next decade. Followup question: how can you be confident enough in your risk model that you can purposefully consume error budget to move faster without worrying that a downstream (in time) bad event will put you overbudget? Nat Welch (a former Google SRE) responded to this by saying that you can build confidence through simulated disasters and other testing.</em></p> <h4 id="monitoring">Monitoring</h4> <ul> <li>Monitoring should never require a human to interpret any part of the alerting domain</li> <li>Three valid kinds of monitoring output <ul> <li>Alerts: human needs to take action immediately</li> <li>Tickets: human needs to take action eventually</li> <li>Logging: no action needed</li> <li>Note that, for example, graphs are a type of log</li> </ul></li> </ul> <h4 id="emergency-response">Emergency Response</h4> <ul> <li>Reliability is a function of MTTF (mean-time-to-failure) and MTTR (mean-time-to-recovery)</li> <li>For evaluating responses, we care about MTTR</li> <li>Humans add latency</li> <li>Systems that don’t require humans to respond will have higher availability due to lower MTTR</li> <li>Having a “playbook” produces 3x lower MTTR <ul> <li>Having hero generalists who can respond to everything works, but having playbooks works better</li> </ul></li> </ul> <p><em>I personally agree, but boy do we like our on call heros. I wonder how we can foster a culture of documentation.</em></p> <h4 id="change-management">Change management</h4> <ul> <li>70% of outages due to changes in a live system. Mitigation: <ul> <li>Implement progressive rollouts</li> <li>Monitoring</li> <li>Rollback</li> </ul></li> <li>Remove humans from the loop, avoid standard human problems on repetitive tasks</li> </ul> <h4 id="demand-forecasting-and-capacity-planning-http-www-amazon-com-gp-product-0596518579-ref-as-li-tl-ie-utf8-camp-1789-creative-9325-creativeasin-0596518579-linkcode-as2-tag-abroaview-20-linkid-ek2pbwyshyk26giv">Demand forecasting and <a href="http://www.amazon.com/gp/product/0596518579/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596518579&amp;linkCode=as2&amp;tag=abroaview-20&amp;linkId=EK2PBWYSHYK26GIV">capacity planning</a></h4> <ul> <li>Straightforward, but a surprising number of teams/services don’t do it</li> </ul> <h4 id="provisioning">Provisioning</h4> <ul> <li>Adding capacity riskier than load shifting, since it often involves spinning up new instances/locations, making significant changes to existing systems (config files, load balancers, etc.)</li> <li>Expensive enough that it should be done only when necessary; must be done quickly <ul> <li>If you don’t know what you actually need and overprovision that costs money</li> </ul></li> </ul> <h4 id="efficiency-and-performance">Efficiency and performance</h4> <ul> <li>Load slows down systems</li> <li>SREs provision to meet capacity target with a specific response time goal</li> <li>Efficiency == money</li> </ul> <h3 id="chapter-2-the-production-environment-at-google-from-the-viewpoint-of-an-sre">Chapter 2: The production environment at Google, from the viewpoint of an SRE</h3> <p><em>No notes on this chapter because I’m already pretty familiar with it. TODO: maybe go back and read this chapter in more detail.</em></p> <h3 id="chapter-3-embracing-risk">Chapter 3: Embracing risk</h3> <ul> <li>Ex: if a user is on a smartphone with 99% reliability, they can’t tell the difference between 99.99% and 99.999% reliability</li> </ul> <h4 id="managing-risk">Managing risk</h4> <ul> <li>Reliability isn’t linear in cost. It can easily cost 100x more to get one additional increment of reliability <ul> <li>Cost associated with redundant equipment</li> <li>Cost of building out features for reliability as opposed to “normal” features</li> <li>Goal: make systems reliable enough, but not too reliable!</li> </ul></li> </ul> <h4 id="measuring-service-risk">Measuring service risk</h4> <ul> <li>Standard practice: identify metric to represent property of system to optimize</li> <li>Possible metric = uptime / (uptime + downtime) <ul> <li>Problematic for a globally distributed service. What does uptime really mean?</li> </ul></li> <li>Aggregate availability = successful requests / total requests <ul> <li>Obv, not all requests are equal, but aggregate availability is an ok first order approximation</li> </ul></li> <li>Usually set quarterly targets</li> </ul> <h4 id="risk-tolerance-of-services">Risk tolerance of services</h4> <ul> <li>Usually not objectively obvious</li> <li>SREs work with product owners to translate business objectives into explicit objectives</li> </ul> <h4 id="identifying-risk-tolerance-of-consumer-services">Identifying risk tolerance of consumer services</h4> <p><em>TODO: maybe read this in detail on second pass</em></p> <h4 id="identifying-risk-tolerance-of-infrastructure-services">Identifying risk tolerance of infrastructure services</h4> <h5 id="target-availability">Target availability</h5> <ul> <li>Running ex: Bigtable <ul> <li>Some consumer services serve data directly from Bigtable -- need low latency and high reliability</li> <li>Some teams use bigtable as a backing store for offline analysis -- care more about throughput than reliability</li> </ul></li> <li>Too expensive to meet all needs generically <ul> <li>Ex: Bigtable instance</li> <li>Low-latency Bigtable user wants low queue depth</li> <li>Throughput oriented Bigtable user wants moderate to high queue depth</li> <li>Success and failure are diametrically opposed in these two cases!</li> </ul></li> </ul> <h5 id="cost">Cost</h5> <ul> <li>Partition infra and offer different levels of service</li> <li>In addition to obv. benefits, allows service to externalize the cost of providing different levels of service (e.g., expect latency oriented service to be more expensive than throughput oriented service)</li> </ul> <h4 id="motivation-for-error-budgets">Motivation for error budgets</h4> <p><em>No notes on this because I already believe all of this. Maybe go back and re-read this if involved in debate about this.</em></p> <h3 id="chapter-4-service-level-objectives">Chapter 4: Service level objectives</h3> <p><em>Note: skipping notes on terminology section.</em></p> <ul> <li>Ex: Chubby planned outages <ul> <li>Google found that Chubby was consistently over its SLO, and that global Chubby outages would cause unusually bad outages at Google</li> <li>Chubby was so reliable that teams were incorrectly assuming that it would never be down and failing to design systems that account for failures in Chubby</li> <li>Solution: take Chubby down globally when it’s too far above its SLO for a quarter to “show” teams that Chubby can go down</li> </ul></li> </ul> <h4 id="what-do-you-and-your-users-care-about">What do you and your users care about?</h4> <ul> <li>Too many indicators: hard to pay attention</li> <li>Too few indicators: might ignore important behavior</li> <li>Different classes of services should have different indicators <ul> <li>User-facing: availability, latency, throughput</li> <li>Storage: latency, availability, durability</li> <li>Big data: throughput, end-to-end latency</li> </ul></li> <li>All systems care about correctness</li> </ul> <h4 id="collecting-indicators">Collecting indicators</h4> <ul> <li>Can often do naturally from server, but client-side metrics sometimes needed.</li> </ul> <h4 id="aggregation">Aggregation</h4> <ul> <li>Use distributions and not averages</li> <li>User studies show that people usually prefer slower average with better tail latency</li> <li>Standardize on common defs, e.g., average over 1 minute, average over tasks in cluster, etc. <ul> <li>Can have exceptions, but having reasonable defaults makes things easier</li> </ul></li> </ul> <h4 id="choosing-targets">Choosing targets</h4> <ul> <li>Don’t pick target based on current performance <ul> <li>Current performance may require heroic effort</li> </ul></li> <li>Keep it simple</li> <li>Avoid absolutes <ul> <li>Unreasonable to talk about “infinite” scale or “always” available</li> </ul></li> <li>Minimize number of SLOs</li> <li>Perfection can wait <ul> <li>Can always redefine SLOs over time</li> </ul></li> <li>SLOs set expectations <ul> <li>Keep a safety margin (internal SLOs can be defined more loosely than external SLOs)</li> </ul></li> <li>Don’t overachieve <ul> <li>See Chubby example, above</li> <li>Another example is making sure that the system isn’t too fast under light loads</li> </ul></li> </ul> <h3 id="chapter-5-eliminating-toil">Chapter 5: Eliminating toil</h3> <p>Carla Geisser: &#34;If a human operator needs to touch your system during normal operations, you have a bug. The definition of normal changes as your systems grow.&#34;</p> <ul> <li>Def: Toil <ul> <li>Not just “work I don’t want to do”</li> <li>Manual</li> <li>Repetitive</li> <li>Automatable</li> <li>Tactical</li> <li>No enduring value</li> <li>O(n) with service growth</li> </ul></li> <li>In surveys, find 33% toil on average <ul> <li>Numbers can be as low as 0% and as high as 80%</li> <li>Toil &gt; 50% is a sign that the manager should spread toil load more evenly</li> </ul></li> <li>Is toil always bad? <ul> <li>Predictable and repetitive tasks can be calming</li> <li>Can produce a sense of accomplishment, can be low-risk / low-stress activities</li> </ul></li> </ul> <p><em>Section on why toil is bad. Skipping notetaking for that section.</em></p> <h3 id="chapter-6-monitoring-distributed-systems">Chapter 6: Monitoring distributed systems</h3> <ul> <li>Why monitor? <ul> <li>Analyze long-term trends</li> <li>Compare over time or do experiments</li> <li>Alerting</li> <li>Building dashboards</li> <li>Debugging</li> </ul></li> </ul> <p><em>As Alex Clemmer is wont to say, our problem isn’t that we move too slowly, it’s that we build the wrong thing. I wonder how we could get from where we are today to having enough instrumentation to be able to make informed decisions when building new systems.</em></p> <h4 id="setting-reasonable-expectations">Setting reasonable expectations</h4> <ul> <li>Monitoring is non-trivial</li> <li>10-12 person SRE team typically has 1-2 people building and maintaining monitoring</li> <li>Number has decreased over time due to improvements in tooling/libs/centralized monitoring infra</li> <li>General trend towards simpler/faster monitoring systems, with better tools for post hoc analysis</li> <li>Avoid “magic” systems</li> <li>Limited success with complex dependency hierarchies (e.g., “if DB slow, alert for DB, otherwise alert for website”). <ul> <li>Used mostly (only?) for very stable parts of system</li> </ul></li> <li>Rules that generate alerts for humans should be simple to understand and represent a clear failure</li> </ul> <p><em>Avoiding magic includes avoiding ML?</em></p> <ul> <li>Lots of white-box monitoring</li> <li>Some black-box monitoring for critical stuff</li> <li>Four golden signals <ul> <li>Latency</li> <li>Traffic</li> <li>Errors</li> <li>Saturation</li> </ul></li> </ul> <p><em>Interesting examples from Bigtable and Gmail from chapter not transcribed. A lot of information on the importance of keeping alerts simple also not transcribed.</em></p> <h4 id="the-long-run">The long run</h4> <ul> <li>There’s often a tension between long-run and short-run availability</li> <li>Can sometimes fix unreliable systems through heroic effort, but that’s a burnout risk and also a failure risk</li> <li>Taking a controlled hit in short-term reliability is usually the better trade</li> </ul> <h3 id="chapter-7-evolution-of-automation-at-google">Chapter 7: Evolution of automation at Google</h3> <ul> <li>“Automation is a force multiplier, not a panacea”</li> <li>Value of automation <ul> <li>Consistency</li> <li>Extensibility</li> <li>MTTR</li> <li>Faster non-repair actions</li> <li>Time savings</li> </ul></li> </ul> <p><em>Multiple interesting case studies and explanations skipped in notes.</em></p> <h3 id="chapter-8-release-engineering">Chapter 8: Release engineering</h3> <ul> <li>This is a specific job function at Google</li> </ul> <h4 id="release-engineer-role">Release engineer role</h4> <ul> <li>Release engineers work with SWEs and SREs to define how software is released <ul> <li>Allows dev teams to focus on dev work</li> </ul></li> <li>Define best practices <ul> <li>Compiler flags, formats for build ID tags, etc.</li> </ul></li> <li>Releases automated</li> <li>Models vary between teams <ul> <li>Could be “push on green” and deploy every build</li> <li>Could be hourly builds and deploys</li> <li>etc.</li> </ul></li> <li>Hermetic builds <ul> <li>Building same rev number should always give identical results</li> <li>Self-contained -- this includes versioning everything down the compiler used</li> <li>Can cherry-pick fixes against an old rev to fix production software</li> </ul></li> <li>Virtually all changes require code review</li> <li>Branching <ul> <li>All code in main branch</li> <li>Releases are branched off</li> <li>Fixes can go from master to branch</li> <li>Branches never merged back</li> </ul></li> <li>Testing <ul> <li>CI</li> <li>Release process creates an audit trail that runs tests and shows that tests passed</li> </ul></li> <li>Config management <ul> <li>Deceptively simple, <a href="https://danluu.com/postmortem-lessons/">can cause instability</a></li> </ul></li> <li>Many possible schemes (all involve storing config in source control and having strict config review)</li> <li>Use mainline for config -- config maintained at head and applied immediately <ul> <li>Originally used for Borg (and pre-Borg systems)</li> <li>Binary releases and config changes decoupled!</li> </ul></li> <li>Include config files and binaries in same package <ul> <li>Simple</li> <li>Tightly couples binary and config -- ok for projects with few config files or where few configs change</li> </ul></li> <li>Package config into “configuration packages” <ul> <li>Same hermetic principle as for code</li> </ul></li> <li>Release engineering shouldn’t be an afterthought! <ul> <li>Budget resources at beginning of dev cycle</li> </ul></li> </ul> <h3 id="chapter-9-simplicity">Chapter 9: Simplicity</h3> <ul> <li>Stability vs. agility <ul> <li>Can make things stable by freezing -- need to balance the two</li> <li>Reliable systems can increase agility</li> <li>Reliable rollouts make it easier to link changes to bugs</li> </ul></li> <li>Virtue of boring!</li> <li><a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">Essential vs. accidental complexity</a> <ul> <li>SREs should push back when accidental complexity is introduced</li> </ul></li> <li>Code is a liability <ul> <li>Remove dead code or other bloat</li> </ul></li> <li>Minimal APIs <ul> <li>Smaller APIs easier to test, more reliable</li> </ul></li> <li>Modularity <ul> <li>API versioning</li> <li>Same as code, where you’d avoid misc/util classes</li> </ul></li> <li>Releases <ul> <li>Small releases easier to measure</li> <li>Can’t tell what happened if we released 100 changes together</li> </ul></li> </ul> <h3 id="chapter-10-altering-from-time-series-data">Chapter 10: Altering from time-series data</h3> <h4 id="borgmon">Borgmon</h4> <ul> <li>Similar-ish to <a href="https://prometheus.io/">Prometheus</a></li> <li>Common data format for logging</li> <li>Data used for both dashboards and alerts</li> <li>Formalized a legacy data format, “varz”, which allowed metrics to be viewed via HTTP <ul> <li>To view metrics manually, go to <a href="http://foo:80/varz">http://foo:80/varz</a></li> </ul></li> <li>Adding a metric only requires a single declaration in code <ul> <li>low user-cost to add new metric</li> </ul></li> <li>Borgmon fetches /varz from each target periodically <ul> <li>Also includes synthetic data like health check, if name was resolved, etc.,</li> </ul></li> <li>Time series arena <ul> <li>Data stored in-memory, with checkpointing to disk</li> <li>Fixed sized allocation</li> <li>GC expires oldest entries when full</li> <li>conceptually a 2-d array with time on one axis and items on the other axis</li> <li>24 bytes for a data point -&gt; 1M unique time series for 12 hours at 1-minute intervals = 17 GB</li> </ul></li> <li>Borgmon rules <ul> <li>Algebraic expressions</li> <li>Compute time-series from other time-series</li> <li>Rules evaluated in parallel on a threadpool</li> </ul></li> <li>Counters vs. gauges <ul> <li>Def: counters are non-decreasing</li> <li>Def: can take any value</li> <li>Counters preferred to gauges because gauges can lose information depending on sampling interval</li> </ul></li> <li>Altering <ul> <li>Borgmon rules can trigger alerts</li> <li>Have minimum duration to prevent “flapping”</li> <li>Usually set to two duration cycles so that missed collections don’t trigger an alert</li> </ul></li> <li>Scaling <ul> <li>Borgmon can take time-series data from other Borgmon (uses binary streaming protocol instead of the text-based varz protocol)</li> <li>Can have multiple tiers of filters</li> </ul></li> <li>Prober <ul> <li>Black-box monitoring that monitors what the user sees</li> <li>Can be queried with varz or directly send alerts to Altertmanager</li> </ul></li> <li>Configuration <ul> <li>Separation between definition of rules and targets being monitored</li> </ul></li> </ul> <h3 id="chapter-11-being-on-call">Chapter 11: Being on-call</h3> <ul> <li>Typical response time <ul> <li>5 min for user-facing or other time-critical tasks</li> <li>30 min for less time-sensitive stuff</li> </ul></li> <li>Response times linked to SLOs <ul> <li>Ex: 99.99% for a quarter is 13 minutes of downtime; clearly can’t have response time above 13 minutes</li> <li>Services with looser SLOs can have response times in the 10s of minutes (or more?)</li> </ul></li> <li>Primary vs secondary on-call <ul> <li>Work distribution varies by team</li> <li>In some, secondary can be backup for primary</li> <li>In others, secondary handles non-urgent / non-paging events, primary handles pages</li> </ul></li> <li>Balanced on-call <ul> <li>Def: quantity: percent of time on-call</li> <li>Def: quality: number of incidents that occur while on call</li> </ul></li> </ul> <p><em>This is great. We should do this. People sometimes get really rough on-call rotations a few times in a row and considering the infrequency of on-call rotations there’s no reason to expect that this should randomly balance out over the course of a year or two.</em></p> <ul> <li>Balance in quantity <ul> <li>&gt;= 50% of SRE time goes into engineering</li> <li>Of remainder, no more than 25% spent on-call</li> </ul></li> <li>Prefer multi-site teams <ul> <li>Night shifts are bad for health, multi-site teams allow elimination of night shifts</li> </ul></li> <li>Balance in quality <ul> <li>On average, dealing with an incident (incl root-cause analysis, remediation, writing postmortem, fixing bug, etc.) takes 6 hours.</li> <li>=&gt; shouldn’t have more than 2 incidents in a 12-hour on-call shift</li> <li>To stay within upper bound, want very flat distribution of pages, with median value of 0</li> </ul></li> <li>Compensation -- extra pay for being on-call (time-off or cash)</li> </ul> <h3 id="chapter-12-effective-troubleshooting">Chapter 12: Effective troubleshooting</h3> <p><em>No notes for this chapter.</em></p> <h3 id="chapter-13-emergency-response">Chapter 13: Emergency response</h3> <ul> <li>Test-induced emergency <ul> <li><a href="http://queue.acm.org/detail.cfm?id=2371516">SREs break systems to see what happens</a></li> </ul></li> <li>Ex: want to flush out hidden dependencies on a distributed MySQL database <ul> <li>Plan: block access to 1/100 of DBs</li> <li>Response: dependent services report that they’re unable to access key systems</li> <li>SRE response: SRE aborts exercise, tries to roll back permissions change</li> <li>Rollback attempt fails</li> <li>Attempt to restore access to replicas works</li> <li>Normal operation restored in 1 hour</li> <li>What went well: dependent teams escalated issues immediately, were able to restore access</li> <li>What we learned: had an insufficient understanding of the system and its interaction with other systems, failed to follow incident response that would have informed customers of outage, hadn’t tested rollback procedures in test env</li> </ul></li> <li>Change-induced emergency <ul> <li>Changes can cause failures!</li> </ul></li> <li>Ex: config change to abuse prevention infra pushed on Friday triggered crash-loop bug <ul> <li>Almost all externally facing systems depend on this, become unavailable</li> <li>Many internal systems also have dependency and become unavailable</li> <li>Alerts start firing with seconds</li> <li>Within 5 minutes of config push, engineer who pushed change rolled back change and services started recovering</li> <li>What went well: monitoring fired immediately, incident management worked well, out-of-band communications systems kept people up to date even though many systems were down, luck (engineer who pushed change was following real-time comms channels, which isn’t part of the release procedure)</li> <li>What we learned: push to canary didn’t trigger same issue because it didn’t hit a specific config keyword combination; push was considered low-risk and went through less stringent canary process, alerting was too noisy during outage</li> </ul></li> <li>Process-induced emergency</li> </ul> <p><em>No notes on process-induced example.</em></p> <h3 id="chapter-14-managing-incidents">Chapter 14: Managing incidents</h3> <p><em>This is an area where we seem to actually be pretty good. No notes on this chapter.</em></p> <h3 id="chapter-15-postmortem-culture-learning-from-failure">Chapter 15: Postmortem culture: learning from failure</h3> <p><em><a href="https://danluu.com/postmortem-lessons/">I&#39;m in strong agreement with most of this chapter</a>. No notes.</em></p> <h3 id="chapter-16-tracking-outages">Chapter 16: Tracking outages</h3> <ul> <li>Escalator: centralized system that tracks ACKs to alerts, notifies other people if necessary, etc.</li> <li>Outalator: gives time-interleaved view of notifications for multiple queues <ul> <li>Also saves related email and allows marking some messages as “important”, can collapse non-important messages, etc.</li> </ul></li> </ul> <p><em>Our version of Escalator seems fine. We could really use something like Outalator, though.</em></p> <h3 id="chapter-17-testing-for-reliability">Chapter 17: Testing for reliability</h3> <p><em>Preaching to the choir. No notes on this section. We could really do a lot better here, though.</em></p> <h3 id="chapter-18-software-engineering-in-sre">Chapter 18: Software engineering in SRE</h3> <ul> <li>Ex: Auxon, capacity planning automation tool</li> <li>Background: traditional capacity planning cycle <ul> <li>1) collect demand forecasts (quarters to years in advance)</li> <li>2) Plan allocations</li> <li>3) Review plan</li> <li>4) Deploy and config resources</li> </ul></li> <li>Traditional approach cons <ul> <li>Many things can affect plan: increase in efficiency, increase in adoption rate, cluster delivery date slips, etc.</li> <li>Even small changes require rechecking allocation plan</li> <li>Large changes may require total rewrite of plan</li> <li>Labor intensive and error prone</li> </ul></li> <li>Google solution: intent-based capacity planning <ul> <li>Specify requirements, not implementation</li> <li>Encode requirements and autogenerate a capacity plan</li> <li>In addition to saving labor, solvers can do better than human generated solutions =&gt; cost savings</li> </ul></li> <li>Ladder of examples of increasingly intent based planning <ul> <li>1) Want 50 cores in clusters X, Y, and Z -- why those resources in those clusters?</li> <li>2) Want 50-core footprint in any 3 clusters in region -- why that many resources and why 3?</li> <li>3) Want to meet demand with N+2 redundancy -- why N+2?</li> <li>4) Want 5 9s of reliability. Could find, for example, that N+2 isn’t sufficient</li> </ul></li> <li>Found that greatest gains are from going to (3) <ul> <li>Some sophisticated services may go for (4)</li> </ul></li> <li>Putting constraints into tools allows tradeoffs to be consistent across fleet <ul> <li>As opposed to making individual ad hoc decisions</li> </ul></li> <li>Auxon inputs <ul> <li>Requirements (e.g., “service must be N+2 per continent”, “frontend servers no more than 50ms away from backend servers”</li> <li>Dependencies</li> <li>Budget priorities</li> <li>Performance data (how a service scales)</li> <li>Demand forecast data (note that services like Colossus have derived forecasts from dependent services)</li> <li>Resource supply &amp; pricing</li> </ul></li> <li>Inputs go into solver (mixed-integer or linear programming solver)</li> </ul> <p><em>No notes on why SRE software, how to spin up a group, etc. TODO: re-read back half of this chapter and take notes if it’s ever directly relevant for me.</em></p> <h3 id="chapter-19-load-balancing-at-the-frontend">Chapter 19: Load balancing at the frontend</h3> <p><em>No notes on this section. Seems pretty similar to what we have in terms of high-level goals, and the chapter doesn’t go into low-level details. It’s notable that they do [redacted] differently from us, though. For more info on lower-level details, there’s <a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eisenbud.pdf">the Maglev paper</a>.</em></p> <h3 id="chapter-20-load-balancing-in-the-datacenter">Chapter 20: Load balancing in the datacenter</h3> <ul> <li>Flow control</li> <li>Need to avoid unhealthy tasks</li> <li>Naive flow control for unhealthy tasks <ul> <li>Track number of requests to a backend</li> <li>Treat backend as unhealthy when threshold is reached</li> <li>Cons: generally terrible</li> </ul></li> <li>Health-based flow control <ul> <li>Backend task can be in one of three states: {healthy, refusing connections, lame duck}</li> <li>Lame duck state can still take connections, but sends backpressure request to all clients</li> <li>Lame duck state simplifies clean shutdown</li> </ul></li> <li>Def: subsetting: limiting pool of backend tasks that a client task can interact with <ul> <li>Clients in RPC system maintain pool of connections to backends</li> <li>Using pool reduces latency compared to doing setup/teardown when needed</li> <li>Inactive connections are relatively cheap, but not free, even in “inactive” mode (reduced health checks, UDP instead of TCP, etc.)</li> </ul></li> <li>Choosing the correct subset <ul> <li>Typ: 20-100, choose base on workload</li> </ul></li> <li>Subset selection: random <ul> <li>Bad utilization</li> </ul></li> <li>Subset selection: round robin <ul> <li>Order is permuted; each round has its own permutation</li> </ul></li> <li>Load balancing <ul> <li>Subset selection is for connection balancing, but we still need to balance load</li> </ul></li> <li>Load balancing: round robin <ul> <li>In practice, observe 2x difference between most loaded and least load</li> <li>In practice, most expensive request can be 1000x more expensive than cheapest request</li> <li>In addition, there’s random unpredictable variation in requests</li> </ul></li> <li>Load balancing: least-loaded round robin <ul> <li>Exactly what it sounds like: round-robin among least loaded backends</li> <li>Load appears to be measured in terms of connection count; may not always be the best metric</li> <li>This is per client, not globally, so it’s possible to send requests to a backend with many requests from other clients</li> <li>In practice, for larg services, find that most-loaded task uses twice as much CPU as least-loaded; similar to normal round robin</li> </ul></li> <li>Load balancing: weighted round robin <ul> <li>Same as above, but weight with other factors</li> <li>In practice, much better load distribution than least-loaded round robin</li> </ul></li> </ul> <p><em>I wonder what Heroku meant when they responded to <a href="http://genius.com/James-somers-herokus-ugly-secret-annotated">Rap Genius</a> by saying “after extensive research and experimentation, we have yet to find either a theoretical model or a practical implementation that beats the simplicity and robustness of random routing to web backends that can support multiple concurrent connections”.</em></p> <h3 id="chapter-21-handling-overload">Chapter 21: Handling overload</h3> <ul> <li>Even with “good” load balancing, systems will become overloaded</li> <li>Typical strategy is to serve degraded responses, but under very high load that may not be possible</li> <li>Modeling capacity as QPS or as a function of requests (e.g., how many keys the requests read) is failure prone <ul> <li>These generally change slowly, but can change rapidly (e.g., because of a single checkin)</li> </ul></li> <li>Better solution: measure directly available resources</li> <li>CPU utilization is <em>usually</em> a good signal for provisioning <ul> <li>With GC, memory pressure turns into CPU utilization</li> <li>With other systems, can provision other resources such that CPU is likely to be limiting factor</li> <li>In cases where over-provisioning CPU is too expensive, take other resources into account</li> </ul></li> </ul> <p><em>How much does it cost to generally over-provision CPU like that?</em></p> <ul> <li>Client-side throttling <ul> <li>Backends start rejecting requests when customer hits quota</li> <li>Requests still use resources, even when rejected -- without throttling, backends can spend most of their resources on rejecting requests</li> </ul></li> <li>Criticality <ul> <li>Seems to be priority but with a different name?</li> <li>First-class notion in RPC system</li> <li>Client-side throttling keeps separate stats for each level of criticality</li> <li>By default, criticality is propagated through subsequent RPCs</li> </ul></li> <li>Handling overloaded errors <ul> <li>Shed load to other DCs if DC is overloaded</li> <li>Shed load to other backends if DC is ok but some backends are overloaded</li> </ul></li> <li>Clients retry when they get an overloaded response <ul> <li>Per-request retry budget (3)</li> <li>Per-client retry budget (10%)</li> <li>Failed retries from client cause “overloaded; don’t retry” response to be returned upstream</li> </ul></li> </ul> <p><em>Having a “don’t retry” response is “obvious”, but relatively rare in practice. A lot of real systems have a problem with failed retries causing more retries up the stack. This is especially true when crossing a hardware/software boundary (e.g., filesystem read causes many retries on DVD/SSD/spinning disk, fails, and then gets retried at the filesystem level), but seems to be generally true in pure software too.</em></p> <h3 id="chapter-22-addressing-cascading-failures">Chapter 22: Addressing cascading failures</h3> <ul> <li>Typical failure scenarios?</li> <li>Server overload</li> <li>Ex: have two servers <ul> <li>One gets overloaded, failing</li> <li>Other one now gets all traffic and also fails</li> </ul></li> <li>Resource exhaustion <ul> <li>CPU/memory/threads/file descriptors/etc.</li> </ul></li> <li>Ex: dependencies among resources <ul> <li>1) Java frontend has poorly tuned GC params</li> <li>2) Frontend runs out of CPU due to GC</li> <li>3) CPU exhaustion slows down requests</li> <li>4) Increased queue depth uses more RAM</li> <li>5) Fixed memory allocation for entire frontend means that less memory is available for caching</li> <li>6) Lower hit rate</li> <li>7) More requests into backend</li> <li>8) Backend runs out of CPU or threads</li> <li>9) Health checks fail, starting cascading failure</li> <li>Difficult to determine cause during outage</li> </ul></li> <li>Note: policies that avoid servers that serve errors can make things worse <ul> <li>fewer backends available, which get too many requests, which then become unavailable</li> </ul></li> <li>Preventing server overload <ul> <li>Load test! Must have realistic environment</li> <li>Serve degraded results</li> <li>Fail cheaply and early when overloaded</li> <li>Have higher-level systems reject requests (at reverse proxy, load balancer, and on task level)</li> <li>Perform capacity planning</li> </ul></li> <li>Queue management <ul> <li>Queues do nothing in steady state</li> <li>Queued reqs consume memory and increase latency</li> <li>If traffic is steady-ish, better to keep small queue size (say, 50% or less of thread pool size)</li> <li>Ex: Gmail uses queueless servers with failover when threads are full</li> <li>For bursty workloads, queue size should be function of #threads, time per req, size/freq of bursts</li> <li>See also, <a href="http://queue.acm.org/detail.cfm?id=2839461">adaptive LIFO and CoDel</a></li> </ul></li> <li>Graceful degradation <ul> <li>Note that it’s important to test graceful degradation path, maybe by running a small set of servers near overload regularly, since this path is rarely exercised under normal circumstances</li> <li>Best to keep simple and easy to understand</li> </ul></li> <li>Retries <ul> <li>Always use randomized exponential backoff</li> <li>See previous chapter on only retrying at a single level</li> <li>Consider having a server-wide retry budget</li> </ul></li> <li>Deadlines <ul> <li>Don’t do work where deadline has been missed (common theme for cascading failure)</li> <li>At each stage, check that deadline hasn’t been hit</li> <li>Deadlines should be propagated (e.g., even through RPCs)</li> </ul></li> <li>Bimodal latency <ul> <li>Ex: problem with long deadline</li> <li>Say frontend has 10 servers, 100 threads each (1k threads of total cap)</li> <li>Normal operation: 1k QPS, reqs take 100ms =&gt; 100 worker threads occupied (1k QPS * .1s)</li> <li>Say 5% of operations don’t complete and there’s a 100s deadline</li> <li>That consumes 5k threads (50 QPS * 100s)</li> <li>Frontend oversubscribed by 5x. Success rate = 1k / (5k + 95) = 19.6% =&gt; 80.4% error rate</li> </ul></li> </ul> <p><em>Using deadlines instead of timeouts is great. We should really be more systematic about this.</em></p> <p><em>Not allowing systems to fill up with pointless zombie requests by setting reasonable deadlines is “obvious”, but a lot of real systems seem to have arbitrary timeouts at nice round human numbers (30s, 60s, 100s, etc.) instead of deadlines that are assigned with load/cascading failures in mind.</em></p> <ul> <li>Try to avoid intra-layer communication <ul> <li>Simpler, avoids possible cascading failure paths</li> </ul></li> <li>Testing for cascading failures <ul> <li>Load test components!</li> <li>Load testing both reveals breaking and point ferrets out components that will totally fall over under load</li> <li>Make sure to test each component separately</li> <li>Test non-critical backends (e.g., make sure that spelling suggestions for search don’t impede the critical path)</li> </ul></li> <li>Immediate steps to address cascading failures <ul> <li>Increase resources</li> <li>Temporarily stop health check failures/deaths</li> <li>Restart servers (only if that would help -- e.g., in GC death spiral or deadlock)</li> <li>Drop traffic -- drastic, last resort</li> <li>Enter degraded mode -- requires having built this into service previously</li> <li>Eliminate batch load</li> <li>Eliminate bad traffic</li> </ul></li> </ul> <h3 id="chapter-23-distributed-consensus-for-reliability">Chapter 23: Distributed consensus for reliability</h3> <ul> <li>How do we agree on questions like… <ul> <li>Which process is the leader of a group of processes?</li> <li>What is the set of processes in a group?</li> <li>Has a message been successfully committed to a distributed queue?</li> <li>Does a process hold a particular lease?</li> <li>What’s the value in a datastore for a particular key?</li> </ul></li> <li>Ex1: split-brain <ul> <li>Service has replicated file servers in different racks</li> <li>Must avoid writing simultaneously to both file servers in a set to avoid data corruption</li> <li>Each pair of file servers has one leader &amp; one follower</li> <li>Servers monitor each other via heartbeats</li> <li>If one server can’t contact the other, it sends a STONITH (shoot the other node in the head)</li> <li>But what happens if the network is slow or packets get dropped?</li> <li>What happens if both servers issue STONITH?</li> </ul></li> </ul> <p><em>This reminds me of one of my favorite distributed database postmortems. The database is configured as a ring, where each node talks to and replicates data into a “neighborhood” of 5 servers. If some machines in the neighborhood go down, other servers join the neighborhood and data gets replicated appropriately.</em></p> <p><em>Sounds good, but in the case where a server goes bad and decides that no data exists and all of its neighbors are bad, it can return results faster than any of its neighbors, as well as tell its neighbors that they’re all bad. Because the bad server has no data it’s very fast and can report that its neighbors are bad faster than its neighbors can report that it’s bad. Whoops!</em></p> <ul> <li>Ex2: failover requires human intervention <ul> <li>A highly sharded DB has a primary for each shard, which replicates to a secondary in another DC</li> <li>External health checks decide if the primary should failover to its secondary</li> <li>If the primary can’t see the secondary, it makes itself unavailable to avoid the problems from “Ex1”</li> <li>This increases operational load</li> <li>Problems are correlated and this is relatively likely to run into problems when people are busy with other issues</li> <li>If there’s a network issues, there’s no reason to think that a human will have a better view into the state of the world than machines in the system</li> </ul></li> <li>Ex3: faulty group-membership algorithms <ul> <li><em>What it sounds like. No notes on this part</em></li> </ul></li> <li>Impossibility results <ul> <li><a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP</a>: P is impossible in real networks, so choose C or A</li> <li><a href="http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/">FLP</a>: async distributed consensus can’t gaurantee progress with unreliable network</li> </ul></li> </ul> <h4 id="paxos-http-research-microsoft-com-en-us-um-people-lamport-pubs-paxos-simple-pdf"><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">Paxos</a></h4> <ul> <li>Sequence of proposals, which may or may not be accepted by the majority of processes <ul> <li>Not accepted =&gt; fails</li> <li>Sequence number per proposal, must be unique across system</li> </ul></li> <li>Proposal <ul> <li>Proposer sends seq number to acceptors</li> <li>Acceptor agrees if it hasn’t seen a higher seq number</li> <li>Proposers can try again with higher seq number</li> <li>If proposer recvs agreement from majority, it commits by sending commit message with value</li> <li>Acceptors must journal to persistent storage when they accept</li> </ul></li> </ul> <h4 id="patterns">Patterns</h4> <ul> <li>Distributed consensus algorithms are a low-level primitive</li> <li>Reliable replicated state machines <ul> <li>Fundamental building block for data config/storage, locking, leader election, etc.</li> <li>See these papers: <a href="https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">Schnieder</a>, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.174.8238&amp;rep=rep1&amp;type=pdf">Aguilera</a>, <a href="http://www.cnds.jhu.edu/pub/papers/psb_ladis_08.pdf">Amir &amp; Kirsch</a></li> </ul></li> <li>Reliable repliacted data and config stores <ul> <li>Non distributed-consensus-based systems often use timestamps: problematic because clock synchrony can&#39;t be gauranteed</li> <li>See <a href="http://research.google.com/archive/spanner.html">Spanner paper</a> for an example of using distributed consensus</li> </ul></li> <li>Leader election <ul> <li>Equivalent to distributed consensus</li> <li>Where work of the leader can performed performed by one process or sharded, leader election pattern allows writing distributed system as if it were a simple program</li> <li>Used by, for example, GFS and Colussus</li> </ul></li> <li>Distributed coordination and locking services <ul> <li>Barrier used, for example, in MapReduce to make sure that Map is finished before Reduce proceeds</li> </ul></li> <li>Distributed queues and messaging <ul> <li>Queues: can tolerate failures from worker nodes, but system needs to ensure that claimed tasks are processed</li> <li>Can use leases instead of removal from queue</li> <li>Using RSM means that system can continue processing even when queue goes down</li> </ul></li> <li>Performance <ul> <li>Conventional wisdom that consensus algorithms can&#39;t be used for high-throughput low-latency systems is false</li> <li>Distributed consensus at the core of many Google systems</li> <li>Scale makes this worse for Google than most other companies, but it still works</li> </ul></li> <li>Multi-Paxos <ul> <li>Strong leader process: unless a leader has not yet been elected or a failure occurs, only one round trip required to reach consensus</li> <li>Note that another process in the group can propose at any time</li> <li>Can ping pong back and forth and pseudo-livelock</li> <li>Not unqique to multi-paxos,</li> <li>Standard solutions are to elect a proposer process or use rotating proposer</li> </ul></li> <li>Scaling read-heavy workloads <ul> <li>Ex: Photon allows reads from any replica</li> <li>Read from stale replica requres extra work, but doesn&#39;t produce bad incorrect results</li> <li>To gaurantee reads are up to date, do one of the following:</li> <li>1) Perform a read-only consensus operation</li> <li>2) Read data from replica that&#39;s guaranteed to be most-up-to-date (stable leader can provide this guarantee)</li> <li>3) Use quorum leases</li> </ul></li> <li><a href="http://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-14-105_abs.shtml">Quorum leases</a> <ul> <li>Replicas can be granted lease over some (or all) data in the system</li> </ul></li> <li>Fast Paxos <ul> <li>Designed to be faster over WAN</li> <li>Each client can send <code>Propose</code> to each member of a group of acceptors directly, instead of through a leader</li> <li><a href="http://www.sysnet.ucsd.edu/sysnet/miscpapers/hotdep07.pdf">Not necessarily faster than classic Paxos</a> -- if RTT to acceptors is long, we&#39;ve traded one message across slow link plus N in parallel across fast link for N across slow link</li> </ul></li> <li>Stable leaders <ul> <li>&#34;Almost all distributed consensus systems that have been designed with performance in mind use either the single stable leader pattern or a system of rotating leadership&#34;</li> </ul></li> </ul> <p><em>TODO: finish this chapter?</em></p> <h3 id="chapter-24-distributed-cron">Chapter 24: Distributed cron</h3> <p><em>TODO: go back and read in more detail, take notes.</em></p> <h3 id="chapter-25-data-processing-pipelines">Chapter 25: Data processing pipelines</h3> <ul> <li>Examples of this are MapReduce or Flume</li> <li>Convenient and easy to reason about the happy case, but fragile <ul> <li>Initial install is usually ok because worker sizing, chunking, parameters are carefully tuned</li> <li>Over time, load changes, causes problems</li> </ul></li> </ul> <h3 id="chapter-26-data-integrity">Chapter 26: Data integrity</h3> <ul> <li>Definition not necessarily obvious <ul> <li>If an interface bug causes Gmail to fail to display messages, that’s the same as the data being gone from the user’s standpoint</li> <li>99.99% uptime means 1 hour of downtime per year. Probably ok for most apps</li> <li>99.99% good bytes in a 2GB file means 200K corrupt. Probably not ok for most apps</li> </ul></li> <li>Backup is non-trivial <ul> <li>May have mixture of transactional and non-transactional backup and restore</li> <li>Different versions of business logic might be live at once</li> <li>If services are independently versioned, maybe have many combinations of versions</li> <li>Replicas aren’t sufficient -- replicas may sync corruption</li> </ul></li> <li>Study of 19 data recovery efforts at Google <ul> <li>Most common user-visible data loss caused by deletion or loss of referential integrity due to software bugs</li> <li>Hardest cases were low-grade corruption discovered weeks to months later</li> </ul></li> </ul> <h4 id="defense-in-depth">Defense in depth</h4> <ul> <li>First layer: soft deletion <ul> <li>Users should be able to delete their data</li> <li>But that means that users will be able to accidentally delete their data</li> <li>Also, account hijacking, etc.</li> <li>Accidentally deletion can also happen due to bugs</li> <li>Soft deletion delays actual deletion for some period of time</li> </ul></li> <li>Second layer: backups <ul> <li>Need to figure out how much data it’s ok to lose during recovery, how long recovery can take, and how far back backups need to go</li> <li>Want backups to go back forever, since corruption can go unnoticed for months (or longer)</li> <li>But changes to code and schema can make recovery of older backups expensive</li> <li>Google usually has 30 to 90 day window, depending on the service</li> </ul></li> <li>Third layer: early detection <ul> <li>Out-of-band integrity checks</li> <li>Hard to do this right!</li> <li>Correct changes can cause checkers to fail</li> <li>But loosening checks can cause failures to get missed</li> </ul></li> </ul> <p><em>No notes on the two interesting case studies covered.</em></p> <h3 id="chapter-27-reliable-product-launches-at-scale">Chapter 27: Reliable product launches at scale</h3> <p><em>No notes on this chapter in particular. A lot of this material is covered by or at least implied by material in other chapters. Probably worth at least looking at example checklist items and action items before thinking about launch strategy, though. Also see appendix E, launch coordination checklist.</em></p> <h3 id="chapters-28-32-various-chapters-on-management">Chapters 28-32: Various chapters on management</h3> <p><em>No notes on these.</em></p> <h3 id="notes-on-the-notes">Notes on the notes</h3> <p><em>I like this book a lot. If you care about building reliable systems, reading through this book and seeing what the teams around you don’t do seems like a good exercise. That being said, the book isn&#39;t perfect. The two big downsides for me stem from the same issue: this is one of those books that&#39;s a collection of chapters by different people. Some of the editors are better than others, meaning that some of the chapters are clearer than others and that because the chapters seem designed to be readable as standalone chapters, there&#39;s a fair amount of redundancy in the book if you just read it straight through. Depending on how you plan to use the book, that can be a positive, but it&#39;s a negative to me. But even including he downsides, I&#39;d say that this is the most valuable technical book I&#39;ve read in the past year and I&#39;ve covered probably 20% of the content in this set of notes. If you really like these notes, you&#39;ll probably want to read the <a href="https://www.amazon.com/gp/product/149192912X/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=abroaview-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=149192912X&amp;linkId=2a578b357abc8b995368a039dd517601">full book</a>.</em></p> <p><em>If you found this set of notes way too dry, maybe try <a href="http://nostalgebraist.tumblr.com/post/142489665564/brazenautomaton-nostalgebraist-the-book-bad">this much more entertaining set of notes on a totally different book</a>. If you found this to only be slightly too dry, maybe try <a href="http://danluu.com/postmortem-lessons/">this set of notes on classes of errors commonly seen in postmortems</a>. In any case, <a href="https://twitter.com/danluu">I’d appreciate feedback on these notes</a>. Writing up notes is an experiment for me. If people find these useful, I&#39;ll try to write up notes on books I read more often. If not, I might try a different approach to writing up notes or some other kind of post entirely.</em></p> </div></div>
        </section>
    </article>
</main>
</body>
</html>
