<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Testing v. informal reasoning | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/tests-v-reason/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Testing v. informal reasoning</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p>This is an off-the-cuff comment for Hacker School&#39;s Paper of the Week Read Along series for <a href="https://github.com/papers-we-love/papers-we-love/raw/master/design/out-of-the-tar-pit.pdf">Out of the Tar Pit</a>.</p>  <p>I find the idea itself, which is presented in sections 7-10, at the end of the paper, pretty interesting. However, I have some objections to the motivation for the idea, which makes up the first 60% of the paper.</p> <p>Rather than do one of those blow-by-blow rebuttals that&#39;s so common on blogs, I&#39;ll limit my comments to one widely circulated idea that I believe is not only mistaken but actively harmful.</p> <p>There&#39;s a claim that “informal reasoning” is more important than “testing”, based mostly on the strength of this quote from Dijkstra:</p> <blockquote> <p>testing is hopelessly inadequate....(it) can be used very effectively to show the presence of bugs but never to show their absence.</p> </blockquote> <p>They go on to make a number of related claims, like “The key problem is that a test (of any kind) on a system or component that is in one particular state tells you nothing at all about the behavior of that system or component when it happens to be in another state.”, with the conclusion that stateless simplicity is the only possible fix. Needless to say, they assume that simplicity is actually possible.</p> <p>I actually agree with the bit about testing -- there&#39;s no way to avoid bugs if you create a system that&#39;s too complex to formally verify.</p> <p>However, there are plenty of real systems with too much irreducible complexity to make simple. Drawing from my own experience, no human can possibly hope to understand a modern high-performance CPU well enough to informally reason about its correctness. That&#39;s not only true now, it&#39;s been true for decades. It becomes true the moment someone introduces any sort of speculative execution or caching. These things are inherently stateful and complicated. They&#39;re so complicated that the only way to model performance (in order to run experiments to design high performance chips) is to simulate precisely what will happen, since the exact results are too complex for humans to reason about and too messy to be mathematically tractable. It&#39;s possible to make a simple CPU, but not one that&#39;s fast and simple. This doesn&#39;t only apply to CPUs -- performance complexity <a href="http://duartes.org/gustavo/blog/post/performance-is-a-science/">leaks all the way up the stack</a>.</p> <p>And it&#39;s not only high performance hardware and software that&#39;s complex. Some domains are just really complicated. The tax code is <a href="http://finance.townhall.com/columnists/politicalcalculations/2014/04/13/2014-how-many-pages-in-the-us-tax-code-n1823832">73k pages long</a>. It&#39;s just not possible to reason effectively about something that complicated, and there are plenty of things that are that complicated.</p> <p>And then there&#39;s the fact that we&#39;re human. We make mistakes. Euclid&#39;s elements contains a bug in the very first theorem. Andrew Gelman likes to use <a href="http://andrewgelman.com/2014/12/25/common-sense-statistics/">this example</a> of an &#34;obviously&#34; bogus published probability result (but not obvious to the authors or the peer reviewers). One of the famous Intel CPU bugs allegedly comes from not testing something because they &#34;knew&#34; it was correct. No matter how smart or knowledgeable, humans are incapable of reasoning correctly all of the time.</p> <p>So what do you do? You write tests! They&#39;re necessary for anything above a certain level of complexity. The argument the authors make is that they&#39;re not sufficient because the state space is huge and a test of one state tells you literally nothing about a test of any other state.</p> <p>That&#39;s true if you look at your system as some kind of unknowable black box, but it turns out to be untrue in practice. There are plenty of <a href="http://researcher.watson.ibm.com/researcher/view_group.php?id=2987">unit testing tools</a> that will do state space reduction based on how similar inputs affect similar states, do symbolic execution, etc. This turns out to work pretty well.</p> <p>And even without resorting to formal methods, you can see this with plain old normal tests. John Regehr has noted that when <a href="http://embed.cs.utah.edu/csmith/">Csmith</a> finds a bug, test case reduction often finds a slew of other bugs. Turns out, tests often tell you something about nearby states.</p> <p>This is not just a theoretical argument. I did CPU design/verification/test for 7.5 years at a company that relied primarily on testing. In that time I can recall two bugs that were found by customers (as opposed to our testing). One was a manufacturing bug that has no software analogue. The software equivalent would be that the software works for years and then after lots of usage at high temperature 1% of customers suddenly can&#39;t use their software anymore. Bad, but not a failure of anything analogous to software testing.</p> <p>The other bug was a legitimate logical bug (in the cache memory hierarchy, of course). It&#39;s pretty embarrassing that we shipped samples of a chip with a real bug to customers, but I think that most companies would be pretty happy with one logical bug in seven and a half years.</p> <p>Testing may not be sufficient to find all bugs, but it can be sufficient to achieve better reliability than pretty much any software company cares to.</p> <p><small>Thanks (or perhaps anti-thanks) to David Albert for goading me into writing up this response and to Govert Versluis for catching a typo.</small></p>  </div></div>
        </section>
    </article>
</main>
</body>
</html>
