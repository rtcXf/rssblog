<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Given that we spend little on testing, how should we test software? | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/testing/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Given that we spend little on testing, how should we test software?</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p>I&#39;ve been reading a lot about software testing, lately. Coming from a hardware background (CPUs and hardware accelerators), it&#39;s interesting how different software testing is. Bugs in software are much easier to fix, so it makes sense to spend a lot less effort spent on testing. Because less effort is spent on testing, methodologies differ; software testing is biased away from methods with high fixed costs, towards methods with high variable costs. But that doesn&#39;t explain all of the differences, or even most of the differences. Most of the differences come from a cultural <a href="http://en.wikipedia.org/wiki/Path_dependence">path dependence</a>, which shows how non-optimally test effort is allocated in both hardware and software.</p>  <p>I don&#39;t really know anything about software testing, but here are some notes from what I&#39;ve seen at Google, on a few open source projects, and in a handful of papers and demos. Since I&#39;m looking at software, I&#39;m going to avoid talking about how hardware testing isn&#39;t optimal, but I find that interesting, too.</p> <h3 id="manual-test-generation">Manual Test Generation</h3> <p>From what I&#39;ve seen, most test effort on most software projects comes from handwritten tests. On the hardware projects I know of, writing tests by hand consumed somewhere between 1% and 25% of the test effort and was responsible for a much smaller percentage of the actual bugs found. Manual testing is considered ok for sanity checking, and sometimes ok for really dirty corner cases, but it&#39;s not scalable and too inefficient to rely on.</p> <p>It&#39;s true that there&#39;s some software that&#39;s difficult to do automated testing on, but the software projects I&#39;ve worked on have relied pretty much totally on manual testing despite being in areas that are among the easiest to test with automated testing. As far as I can tell, that&#39;s not because someone did a calculation of the tradeoffs and decided that manual testing was the way to go, it&#39;s because it didn&#39;t occur to people that there were alternatives to manual testing.</p> <p>So, what are the alternatives?</p> <h3 id="random-test-generation">Random Test Generation</h3> <p>The good news is that random testing is easy to implement. You can spend <a href="https://github.com/danluu/Fuzz.jl">an hour implementing a random test generator and find tens of bugs</a>, or you can spend more time and find <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=jsfunfuzz">thousands of bugs</a>.</p> <p>You can start with something that&#39;s almost totally random and generates incredibly dumb tests. As you spend more time on it, you can add constraints and generate smarter random tests that find more complex bugs. Some good examples of this are <a href="http://www.squarefree.com/2007/08/02/introducing-jsfunfuzz/">jsfunfuzz</a>, which started out relatively simple and gained smarts as time went out, and Jepsen, which originally checked some relatively simple constraints and can now check linearizability.</p> <p>While you can generate random tests pretty easily, it still takes some time to write a powerful framework or collection of functions. Luckily, this space is well covered by existing frameworks.</p> <h3 id="random-test-generation-framework">Random Test Generation, Framework</h3> <p>Here&#39;s an example of how simple it is to write a JavaScript tests using Scott Feeney&#39;s <a href="https://github.com/graue/gentest">gentest</a>, taken from the gentest readme.</p> <p>You want to test something like</p> <pre><code>function add(x, y) {
  return x + y;
}
</code></pre> <p>To check that addition commutes, so you&#39;d write</p> <pre><code>var t = gentest.types;

forAll([t.int, t.int], &#39;addition is commutative&#39;, function(x, y) {
  return add(x, y) === add(y, x);
});
</code></pre> <p>Instead of checking the values by hand, or writing the code to generate the values, the framework handles that and generates tests for after you when you specify the constraints. QuickCheck-like generative test frameworks tend to be simple enough that they&#39;re no harder to learn how to use than any other unit test or mocking framework.</p> <p>You&#39;ll sometimes hear objections about how random testing can only find shallow bugs because random tests are too dumb to find really complex bugs. For one thing, that assumes that you don&#39;t specify constraints that allow the random generator to generate intricate test cases. But even then, <a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/yuan">this paper</a> analyzed production failures in distributed systems, looking for &#34;critical&#34; bugs, bugs that either took down the entire cluster or caused data corruption, and found that 58% could be caught with very simple tests. Turns out, generating “shallow” random tests is enough to catch most production bugs. And that&#39;s on projects that are unusually serious about testing and static analysis, projects that have much better test coverage than the average project.</p> <p>A specific examples of the effective of naive random testing this is the story John Hughes tells <a href="http://www.cse.chalmers.se/edu/year/2012/course/DIT848/files/13-GL-QuickCheck.pdf">in this talk</a>. It starts out when some people came to him with a problem.</p> <blockquote> <p>We know there is a lurking bug somewhere in the dets code. We have got &#39;bad object&#39; and &#39;premature eof&#39; every other month the last year. We have not been able to track the bug down since the dets files is repaired automatically next time it is opened.</p> </blockquote> <p><img src="https://danluu.com/images/testing/hughes_bug.png" alt="Stack: Application on top of Mnesia on top of Dets on top of File system" width="293" height="487"/></p> <p>An application that ran on top of Mnesia, a distributed database, was somehow causing errors a layer below the database. There were some guesses as to the cause. Based on when they&#39;d seen the failures, maybe something to do with rehashing something or other in files that are bigger than 1GB? But after more than a month of effort, no one was really sure what was going on.</p> <p>In less than a day, with QuickCheck, they found five bugs. After fixing those bugs, they never saw the problem again. Each of the five bugs was reproducible on a database with one record, with at most five function calls. It is very common for bugs that have complex real-world manifestations to be reproducible with really simple test cases, if you know where to look.</p> <p>In terms of developer time, using some kind of framework that generates random tests is a huge win over manually writing tests in a lot of circumstances, and it&#39;s so trivially easy to try out that there&#39;s basically no reason not to do it. The ROI of using more advanced techniques may or may not be worth the extra investment to learn how to implement and use them.</p> <p>While dumb random testing works really well in a lot of cases, it has limits. Not all bugs are shallow. I know of a hardware company that&#39;s very good at finding deep bugs by having people with years or decades of domain knowledge write custom test generators, which then run on N-thousand machines. That works pretty well, but it requires a lot of test effort, much more than makes sense for almost any software.</p> <p>The other option is to build more smarts into the program doing the test generation. There are a ridiculously large number of papers on how to do that, but very few of those papers have turned into practical, robust, software tools. The sort of simple coverage-based test generation used in AFL doesn&#39;t have that many papers on it, but it seems to be effective.</p> <h3 id="random-test-generation-coverage-based">Random Test Generation, Coverage Based</h3> <p>If you&#39;re using an existing framework, coverage-based testing isn&#39;t much harder than using any other sort of random testing. In theory, at least. There are often a lot of knobs you can turn to adjust different settings, as well other complexity.</p> <p>If you&#39;re writing a framework, there are a lot of decisions. Chief among them are what coverage metric to use and how to use that coverage metric to drive test generation.</p> <p>For the first choice, which coverage metric, there are coverage metrics that are tractable, but too simplistic, like function coverage, or line coverage (a.k.a. <a href="http://en.wikipedia.org/wiki/Basic_block">basic block</a> coverage). It&#39;s easy to track those, but it&#39;s also easy to get 100% coverage while missing very serious bugs. And then there are metrics that are great, but intractable, like state coverage or path coverage. Without some kind of magic to collapse equivalent paths or states together, it&#39;s impossible to track those for non-trivial programs.</p> <p>For now, let&#39;s assume we&#39;re not going to use magic, and use some kind of approximation instead. Coming up with good approximations that work in practice often takes a lot of trial and error. Luckily, Michal Zalewski has experimented with a wide variety of different strategies for <a href="http://lcamtuf.coredump.cx/afl/">AFL</a>, a testing tool that instruments code with some coverage metrics that allow the tool to generate smart tests.</p> <p><a href="http://lcamtuf.coredump.cx/afl/technical_details.txt">AFL does the following</a>. Each branch gets something like the following injected, which approximates tracking edges between basic blocks, i.e., which branches are taken and how many times:</p> <pre><code>cur_location = &lt;UNIQUE_COMPILE_TIME_RANDOM_CONSTANT&gt;;
shared_mem[prev_location ^ cur_location]++;
prev_location = cur_location &gt;&gt; 1;
</code></pre> <p>shared_mem happens to be a 64kB array in AFL, but the size is arbitrary.</p> <p>The non-lossy version of this would be to have <code>shared_mem</code> be a map of <code>(prev_location, cur_location) -&gt; int</code>, and increment that. That would track how often each edge (prev_location, cur_location) is taken in the basic block graph.</p> <p>Using a fixed sized array and xor&#39;ing prev_location and cur_location provides lossy compression. To keep from getting too much noise out of trivial changes, for example, running a loop 1200 times vs. 1201 times, AFL only considers a bucket to have changed when it crosses one of the following boundaries: <code>1, 2, 3, 4, 8, 16, 32, or 128</code>. That&#39;s one of the two things that AFL tracks to determine coverage.</p> <p>The other is a global set of all (prev_location, cur_location) tuples, which makes it easy to quickly determine if a tuple/transition is new.</p> <p>Roughly speaking, AFL keeps a queue of “interesting” test cases it&#39;s found and generates mutations of things in the queue to test. If something changes the coverage stat, it gets added to the queue. There&#39;s also some logic to avoid adding test cases that are too slow, and to remove test cases that are relatively uninteresting.</p> <p>AFL is about 13k lines of code, so there&#39;s clearly a lot more to it than that, but, conceptually, it&#39;s pretty simple. Zalewksi explains why he&#39;s kept AFL so simple <a href="http://lcamtuf.coredump.cx/afl/related_work.txt">here</a>. His comments are short enough that they&#39;re worth reading in their entirety if you&#39;re at all interested, but I&#39;ll excerpt a few bits anyway.</p> <blockquote> <p>In the past six years or so, I&#39;ve also seen a fair number of academic papers that dealt with smart fuzzing (focusing chiefly on symbolic execution) and a couple papers that discussed proof-of-concept application of genetic algorithms. I&#39;m unconvinced how practical most of these experiments were … Effortlessly getting comparable results [from AFL] with state-of-the-art symbolic execution in equally complex software still seems fairly unlikely, and hasn&#39;t been demonstrated in practice so far.</p> </blockquote> <h3 id="test-generation-other-smarts">Test Generation, Other Smarts</h3> <p>While Zalewski is right that it&#39;s hard to write a robust and generalizable tool that uses more intelligence, it&#39;s possible to get a lot of mileage out of domain specific tools. For example, <a href="http://db.cs.berkeley.edu/papers/dbtest12-bloom.pdf">BloomUnit</a>, a test framework for distributed systems, helps you test non-deterministic systems by generating a subset of valid orderings, which uses a SAT solver to avoid generating equivalent re-orderings. The authors don&#39;t provide benchmark results the same way Zalewksi does with AFL, but even without benchmarks it&#39;s at least plausible that a SAT solver can be productively applied to test case generation. If nothing else, distributed system tests are often slow enough that you can do a lot of work without severely impacting test throughput.</p> <p>Zalewski says “If your instrumentation makes it 10x more likely to find a bug, but runs 100x slower, your users [are] getting a bad deal.“, which is a great point -- gains in test smartness have to be balanced against losses in test throughput, but if you&#39;re testing with something like Jepsen, where your program under test actually runs on multiple machines that have to communicate with each other, the test is going to be slow enough that you can spend a lot of computation generating smarter tests before getting a 10x or 100x slowdown.</p> <p>This same effect makes it difficult to port smart hardware test frameworks to software. It&#39;s not unusual for a “short” hardware test to take minutes, and for a long test to take hours or days. As a result, spending a massive amount of computation to generate more efficient tests is worth it, but naively porting a smart hardware test framework to software is a recipe for overly clever inefficiency.</p> <h3 id="why-not-coverage-based-unit-testing">Why Not Coverage-Based Unit Testing?</h3> <p>QuickCheck and the tens or hundreds of QuickCheck clones are pretty effective for random unit testing, and AFL is really amazing at coverage-based pseudo-random end-to-end test generation to find crashes and security holes. How come there isn&#39;t a tool that does coverage-based unit testing?</p> <p>I often assume that if there isn&#39;t an implementation of a straightforward idea, there must be some reason, like maybe it&#39;s much harder than it sounds, but <a href="http://www.somerandomidiot.com/">Mindy</a> convinced me that there&#39;s often no reason something hasn&#39;t been done before, so I tried making the simplest possible toy implementation.</p> <p>Before I looked at AFL&#39;s internals, I created this really dumb function to test. The function takes an array of arbitrary length as input and is supposed to return a non-zero int.</p> <pre><code>// Checks that a number has its bottom bits set
func some_filter(x int) bool {
	for i := 0; i &lt; 16; i = i + 1 {
		if !(x&amp;1 == 1) {
			return false
		}
		x &gt;&gt;= 1
	}
	return true
}

// Takes an array and returns a non-zero int
func dut(a []int) int {
	if len(a) != 4 {
		return 1
	}

	if some_filter(a[0]) {
		if some_filter(a[1]) {
			if some_filter(a[2]) {
				if some_filter(a[3]) {
					return 0 // A bug! We failed to return non-zero!
				}
				return 2
			}
			return 3
		}
		return 4
	}
	return 5
}
</code></pre> <p>dut stands for device under test, a commonly used term in the hardware world. This code is deliberately contrived to make it easy for a coverage based test generator to make progress. Since the code does little work as possible per branch and per loop iteration, the coverage metric changes every time we do a bit of additional work. It turns out, that <a href="http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">a lot of software acts like this, despite not being deliberately built this way</a>.</p> <p>Random testing is going to have a hard time finding cases where <code>dut</code> incorrectly returns 0. Even if you set the correct array length, a total of 64 bits have to be set to particular values, so there&#39;s a 1 in 2^64 chance of any particular random input hitting the failure.</p> <p>But a test generator that uses something like AFL&#39;s fuzzing algorithm hits this case almost immediately. Turns out, with reasonable initial inputs, it even finds a failing test case before it really does any coverage-guided test generation because the heuristics AFL uses for generating random tests generate an input that covers this case.</p> <p>That brings up the question of why QuickCheck and most of its clones don&#39;t use heuristics to generate random numbers. The QuickCheck paper mentions that it uses random testing because it&#39;s nearly as good as <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=5010257&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5010257">partition testing</a> and much easier to implement. That may be true, but it doesn&#39;t mean that generating some values using simple heuristics can&#39;t generate better results with the same amount of effort. Since Zalewski has <a href="http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">already done the work of figuring out, empirically, what heuristics are likely to exercise more code paths</a>, it seems like a waste to ignore that and just generate totally random values.</p> <p>Whether or not it&#39;s worth it to use coverage guided generation is a bit iffier; it doesn&#39;t prove anything that a toy coverage-based unit testing prototype can find a bug in a contrived function that&#39;s amenable to coverage based testing. But that wasn&#39;t the point. The point was to see if there was some huge barrier that should prevent people from doing coverage-driven unit testing. As far as I can tell, there isn&#39;t.</p> <p>It helps that the implementation of the golang is very well commented and has good facilities for manipulating go code, which makes it really easy to modify its coverage tools to generate whatever coverage metrics you want, but most languages have some kind of coverage tools that can be hacked up to provide the appropriate coverage metrics so it shouldn&#39;t be too painful for any mature language. And once you&#39;ve got the coverage numbers, generating coverage-guided tests isn&#39;t much harder than generating random QuickCheck like tests. There are some cases where it&#39;s pretty difficult to generate good coverage-guided tests, like when generating functions to test a function that uses higher-order functions, but even in those cases you&#39;re no worse off than you would be with a QuickCheck clone.</p> <h3 id="test-time">Test Time</h3> <p>It&#39;s possible to run software tests much more quickly than hardware tests. One side effect of that is that it&#39;s common to see people proclaim that all tests should run in time bound X, and you&#39;re doing it wrong if they don&#39;t. I&#39;ve heard various values of X from 100ms to 5 minutes. Regardless of the validity of those kinds of statements, a side effect of that attitude is that people often think that running a test generator for a few hours is A LOT OF TESTING. I overheard one comment about how a particular random test tool had found basically all the bugs it could find because, after a bunch of bug fixes, it had been run for a few hours without finding any additional bugs.</p> <p>And then you have hardware companies, which will dedicate thousands of machines to generating and running tests. That probably doesn&#39;t make sense for a software company, but considering the relative cost of a single machine compared to the cost of a developer, it&#39;s almost certainly worth dedicating at least one machine to generating and running tests. And for companies with their own machines, or dedicated cloud instances, generating tests on idle machines is pretty much free.</p> <h3 id="attitude">Attitude</h3> <p>In &#34;Lessons Learned in Software Testing&#34;, the authors mention that QA shouldn&#39;t be expected to find all bugs and that QA shouldn&#39;t have veto power over releases because it&#39;s impossible to catch most important bugs, and thinking that QA will do so leads to sloppiness. That&#39;s a pretty common attitude on the software teams I&#39;ve seen. But on hardware teams, it&#39;s expected that all “bad” bugs will be caught before the final release and QA will shoot down a release if it&#39;s been inadequately tested. Despite that, devs are pretty serious about making things testable by avoiding unnecessary complexity. If a bad bug ever escapes (e.g., the Pentium FDIV bug or the Haswell STM bug), there&#39;s a post-mortem to figure out how the test process could have gone so wrong that a significant bug escaped.</p> <p>It&#39;s hard to say how much of the difference in bug count between hardware and software is attitude, and how much is due to the difference in the amount of effort expended on testing, but I think attitude is a significant factor, in addition to the difference in resources.</p> <p>It affects everything, down to what level of tests people write. There&#39;s a lot of focus on unit testing in software. In hardware, people use the term unit testing, but it usually refers to what would be called an integration test in software. It&#39;s considered too hard to thoroughly test every unit; it&#39;s much less total effort to test “units” that lie on clean API boundaries (which can be internal or external), so that&#39;s where test effort is concentrated.</p> <p>This also drives test generation. If you accept that bad bugs will occur frequently, manually writing tests is ok. But if your goal is to never release a chip with a bad bug, there&#39;s no way to do that when writing tests by hand, so you&#39;ll rely on some combination of random testing, manual testing for tricky edge cases, and formal methods. If you then decide that you don&#39;t have the resources to avoid bad bugs all the time, and you have to scale things back, you&#39;ll be left with the most efficient bug finding methods, which isn&#39;t going to leave a lot of room for writing tests by hand.</p> <h3 id="conclusion">Conclusion</h3> <p>A lot of projects could benefit from more automated testing. Basically every language has a QuickCheck-like framework available, but most projects that are amenable to QuickCheck still rely on manual tests. For all but the tiniest companies, dedicating at least one machine for that kind of testing is probably worth it.</p> <p>I think QuickCheck-like frameworks could benefit from using a coverage driven approach. It&#39;s certainly easy to implement for functions that take arrays of ints, but that&#39;s also pretty much the easiest possible case for something that uses AFL-like test generation (other than, maybe, an array of bytes). It&#39;s possible that this is much harder than I think, but if so, I don&#39;t see why.</p> <p>My background is primarily in hardware, so I could be totally wrong! If you have a software testing background, I&#39;d be really interested in <a href="https://twitter.com/danluu">hearing what you think</a>. Also, I haven&#39;t talked about the vast majority of the topics that testing covers. For example, figuring out what should be tested is really important! So is figuring out how where nasty bugs might be hiding, and having a good regression test setup. But those are pretty similar between hardware and software, so there&#39;s not much to compare and contrast.</p> <h3 id="resources">Resources</h3> <p><a href="http://www.exampler.com/testing-com/writings/coverage.pdf">Brian Marick on code coverage, and how it can be misused</a>.</p> <blockquote> <p>If a part of your test suite is weak in a way that coverage can detect, it&#39;s likely also weak in a way coverage can&#39;t detect.</p> </blockquote> <p>I&#39;m used to bugs being thought of in the same way -- if a test generator takes a month to catch a bug in an area, there are probably other subtle bugs in the same area, and more work needs to be done on the generator to flush them out.</p> <p><a href="http://www.amazon.com/gp/product/0122007514/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0122007514&amp;linkCode=as2&amp;tag=abroaview-20&amp;linkId=DNSHYGZA2USRTHCU">Lessons Learned in Software Testing: A Context-Driven Approach, by Kaner, Bach, &amp; Pettichord</a>. This book is too long to excerpt, but I find it interesting because it reflects a lot of conventional wisdom.</p> <p><a href="http://lcamtuf.coredump.cx/afl/technical_details.txt">AFL whitepaper</a>, <a href="http://lcamtuf.coredump.cx/afl/historical_notes.txt">AFL historical notes</a>, and <a href="http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz">AFL code tarball</a>. All of it is really readable. One of the reasons I spent so much time looking at AFL is because of how nicely documented it is. Another reason is, of course, that it&#39;s been very effective at finding bugs on a wide variety of projects.</p> <p><em>Update: Dmitry Vyukov&#39;s <a href="https://speakerdeck.com/filosottile/automated-testing-with-go-fuzz">Go-fuzz</a>, which looks like it was started a month after this post was written, uses the approach from the proof of concept in this post of combining the sort of logic seen in AFL with a QuickCheck-like framework, and has been shown to be quite effective. I believe David R. MacIver is also planning to use this approach in the next version of <a href="https://hypothesis.readthedocs.org/en/latest/">hypothesis</a>.</em></p> <p>And here&#39;s some testing related stuff of mine: <a href="https://danluu.com/everything-is-broken/">everything is broken</a>, <a href="https://danluu.com/broken-builds/">builds are broken</a>, <a href="https://danluu.com/julialang/">julia is broken</a>, and <a href="https://danluu.com/new-cpu-features/">automated bug finding using analytics</a>.</p> <h3 id="terminology">Terminology</h3> <p>I use the term random testing a lot, in a way that I&#39;m used to using it among hardware folks. I probably mean something broader than what most software folks mean when they say random testing. For example, <a href="http://www.sqlite.org/testing.html">here&#39;s how sqlite describes their testing</a>. There&#39;s one section on fuzz (random) testing, but it&#39;s much smaller than the sections on, say, I/O error testing or OOM testing. But as a hardware person, I&#39;d also put I/O error testing or OOM testing under random testing because I&#39;d expect to use randomly generated tests to test those.</p> <h4 id="acknowledgments">Acknowledgments</h4> <p><small> I&#39;ve gotten great feedback from a lot of software folks! Thanks to Leah Hanson, Mindy Preston, Allison Kaptur, Lindsey Kuper, Jamie Brandon, John Regehr, David Wragg, and Scott Feeney for providing comments/discussion/feedback. </small></p>  </div></div>
        </section>
    </article>
</main>
</body>
</html>
