<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Terminal latency | Rahul Vishwakarma Blog</title>
    <link rel="stylesheet" type="text/css" href="../styles.css" media="screen" />
</head>
<body>
<header>
    <nav>
        <a href="/index.html" aria-label="Go back to the homepage">← Back</a>
        <a href="https://danluu.com/term-latency/" target="_blank" rel="noopener noreferrer">
            View Original
        </a>
    </nav>
</header>

<main>
    <article>
        <h1>Terminal latency</h1>
        <section>
            
            <div id="readability-page-1" class="page"><div> <p>There’s <a href="https://www.youtube.com/watch?v=vOvQCPLkPt4">a great MSR demo from 2012 that shows the effect of latency on the experience of using a tablet</a>. If you don’t want to watch the three minute video, they basically created a device which could simulate arbitrary latencies down to a fraction of a millisecond. At 100ms (1/10th of a second), which is typical of consumer tablets, the experience is terrible. At 10ms (1/100th of a second), the latency is noticeable, but the experience is ok, and at &lt; 1ms the experience is great, as good as pen and paper. If you want to see a mini version of this for yourself, you can try a random Android tablet with a stylus vs. the current generation iPad Pro with the Apple stylus. The Apple device has well above 10ms end-to-end latency, but the difference is still quite dramatic -- it’s enough that I’ll actually use the new iPad Pro to take notes or draw diagrams, whereas I find Android tablets unbearable as a pen-and-paper replacement.</p> <p>You can also see something similar if you try VR headsets with different latencies. <a href="http://oculusrift-blog.com/john-carmacks-message-of-latency/682/">20ms feels fine, 50ms feels laggy, and 150ms feels unbearable</a>.</p> <p>Curiously, I rarely hear complaints about keyboard and mouse input being slow. One reason might be that keyboard and mouse input are quick and that inputs are reflected nearly instantaneously, but I don’t think that’s true. People often tell me that’s true, but I think it’s just the opposite. The idea that computers respond quickly to input, so quickly that humans can’t notice the latency, is the most common performance-related fallacy I hear from professional programmers.</p> <p>When people measure actual end-to-end latency for games on normal computer setups, they usually find latencies in the <a href="http://renderingpipeline.com/2013/09/measuring-input-latency/">100ms</a> <a href="https://www.youtube.com/watch?v=GxaEJY-zd_4&amp;index=5&amp;list=PLfOoCUS0PSkXVGjhB63KMDTOT5sJ0vWy8&amp;t=187s">range</a>.</p> <p>If we look at <a href="http://renderingpipeline.com/2013/09/measuring-input-latency/">Robert Menzel’s breakdown of the the end-to-end pipeline for a game</a>, it’s not hard to see why we expect to see 100+ ms of latency:</p> <ul> <li>~2 msec (mouse)</li> <li>8 msec (average time we wait for the input to be processed by the game)</li> <li>16.6 (game simulation)</li> <li>16.6 (rendering code)</li> <li>16.6 (GPU is rendering the previous frame, current frame is cached)</li> <li>16.6 (GPU rendering)</li> <li>8 (average for missing the vsync)</li> <li>16.6 (frame caching inside of the display)</li> <li>16.6 (redrawing the frame)</li> <li>5 (pixel switching)</li> </ul> <p>Note that this assumes a gaming mouse and a pretty decent LCD; it’s common to see substantially slower latency for the mouse and for pixel switching.</p> <p>It’s possible to tune things to get into the 40ms range, but the vast majority of users don’t do that kind of tuning, and even if they do, that’s still quite far from the 10ms to 20ms range, where tablets and VR start to feel really “right”.</p> <p>Keypress-to-display measurements are mostly done in games because gamers care more about latency than most people, but I don’t think that most applications are all that different from games in terms of latency. While games often do much more work per frame than “typical” applications, they’re also much better optimized than “typical” applications. Menzel budgets 33ms to the game, half for game logic and half for rendering. How much time do non-game applications take? Pavel Fatin measured this for text editors and found latencies ranging from <a href="https://pavelfatin.com/typing-with-pleasure/">a few milliseconds to hundreds of milliseconds</a> and he did this <a href="https://github.com/pavelfatin/typometer">with an app he wrote that we can use to measure the latency of other applications</a> that uses <a href="https://docs.oracle.com/javase/7/docs/api/java/awt/Robot.html">java.awt.Robot</a> to generate keypresses and do screen captures.</p> <p>Personally, I’d like to see the latency of different terminals and shells for a couple of reasons. First, I spend most of my time in a terminal and usually do editing in a terminal, so the latency I see is at least the latency of the terminal. Second, the most common terminal benchmark I see cited (by at least two orders of magnitude) is the rate at which a terminal can display output, often measured by running <code>cat</code> on a large file. This is pretty much as useless a benchmark as I can think of. I can’t recall the last task I did which was limited by the speed at which I can <code>cat</code> a file to <code>stdout</code> on my terminal (well, unless I’m using eshell in emacs), nor can I think of any task for which that sub-measurement is useful. The closest thing that I care about is the speed at which I can <code>^C</code> a command when I’ve accidentally output too much to <code>stdout</code>, but as we’ll see when we look at actual measurements, a terminal’s ability to absorb a lot of input to <code>stdout</code> is only weakly related to its responsiveness to <code>^C</code>. The speed at which I can scroll up or down an entire page sounds related, but in actual measurements the two are not highly correlated (e.g., emacs-eshell is quick at scrolling but extremely slow at sinking <code>stdout</code>). Another thing I care about is latency, but knowing that a particular terminal has high <code>stdout</code> throughput tells me little to nothing about its latency.</p> <p>Let’s look at some different terminals to see if any terminals add enough latency that we’d expect the difference to be noticeable. If we measure the latency from keypress to internal screen capture on my laptop, we see the following latencies for different terminals</p> <p><img src="https://danluu.com/images/term-latency/idle-terminal-latency.svg" alt="Plot of terminal tail latency"/> <img src="https://danluu.com/images/term-latency/loaded-terminal-latency.svg" alt="Plot of terminal tail latency"/></p> <p>These graphs show the distribution of latencies for each terminal. The y-axis has the latency in milliseconds. The x-axis is the percentile (e.g., 50 means represents 50%-ile keypress i.e., the median keypress). Measurements are with macOS unless otherwise stated. The graph on the left is when the machine is idle, and the graph on the right is under load. If we just look at median latencies, some setups don’t look too bad -- terminal.app and emacs-eshell are at roughly 5ms unloaded, small enough that many people wouldn’t notice. But most terminals (st, alacritty, hyper, and iterm2) are in the range <a href="https://pdfs.semanticscholar.org/386a/15fd85c162b8e4ebb6023acdce9df2bd43ee.pdf">where you might expect people</a> to <a href="http://www.tactuallabs.com/papers/howMuchFasterIsFastEnoughCHI15.pdf">notice the additional latency</a> even when the machine is idle. If we look at the tail when the machine is idle, say the 99.9%-ile latency, every terminal gets into the range where the additional latency ought to be perceptible, according to studies on user interaction. For reference, the internally generated keypress to GPU memory trip for some terminals is slower than <a href="http://ipnetwork.bgtmo.ip.att.net/pws/network_delay.html">the time it takes to send a packet from Boston to Seattle <em>and back</em></a>, about 70ms.</p> <p>All measurements were done with input only happening on one terminal at a time, with full battery and running off of A/C power. The loaded measurements were done while compiling Rust (as before, with full battery and running off of A/C power, and in order to make the measurements reproducible, each measurement started 15s after a clean build of Rust after downloading all dependencies, with enough time between runs to avoid thermal throttling interference across runs).</p> <p>If we look at median loaded latencies, other than emacs-term, most terminals don’t do much worse than at idle. But as we look at tail measurements, like 90%-ile or 99.9%-ile measurements, every terminal gets much slower. Switching between macOS and Linux makes some difference, but the difference is different for different terminals.</p> <p>These measurements aren&#39;t anywhere near the worst case (if we run off of battery when the battery is low, and wait 10 minutes into the compile in order to exacerbate thermal throttling, it’s easy to see latencies that are multiple hundreds of ms) but even so, every terminal has tail latency that should be observable. Also, recall that this is only a fraction of the total end-to-end latency.</p> <p>Why don’t people complain about keyboard-to-display latency the way they complain stylus-to-display latency or VR latency? My theory is that, for both VR and tablets, people have a lot of experience with a much lower latency application. For tablets, the “application” is pen-and-paper, and for VR, the “application” is turning your head without a VR headset on. But input-to-display latency is so bad for every application that most people just expect terrible latency.</p> <p>An alternate theory might be that keyboard and mouse input are fundamentally different from tablet input in a way that makes latency less noticeable. Even without any data, I’d find that implausible because, when I access a remote terminal in a way that adds tens of milliseconds of extra latency, I find typing to be noticeably laggy. And it turns out that when extra latency is A/B tested, <a href="http://forums.blurbusters.com/viewtopic.php?f=10&amp;t=1134">people can and do notice latency in the range we’re discussing here</a>.</p> <p>Just so we can compare the most commonly used benchmark (throughput of stdout) to latency, let’s measure how quickly different terminals can sink input on stdout: </p> <div> <table> <thead> <tr> <th>terminal</th> <th>stdout</th> <th>idle50</th> <th>load50</th> <th>idle99.9</th> <th>load99.9</th> <th>mem</th> <th>^C</th> </tr> </thead> <tbody> <tr> <td>alacritty</td> <td>39</td> <td>31</td> <td>28</td> <td>36</td> <td>56</td> <td>18</td> <td>ok</td> </tr> <tr> <td>terminal.app</td> <td>20</td> <td>6</td> <td>13</td> <td>25</td> <td>30</td> <td>45</td> <td>ok</td> </tr> <tr> <td>st</td> <td>14</td> <td>25</td> <td>27</td> <td>63</td> <td>111</td> <td>2</td> <td>ok</td> </tr> <tr> <td>alacritty tmux</td> <td>14</td>       </tr> <tr> <td>terminal.app tmux</td> <td>13</td>       </tr> <tr> <td>iterm2</td> <td>11</td> <td>44</td> <td>45</td> <td>60</td> <td>81</td> <td>24</td> <td>ok</td> </tr> <tr> <td>hyper</td> <td>11</td> <td>32</td> <td>31</td> <td>49</td> <td>53</td> <td>178</td> <td>fail</td> </tr> <tr> <td>emacs-eshell</td> <td>0.05</td> <td>5</td> <td>13</td> <td>17</td> <td>32</td> <td>30</td> <td>fail</td> </tr> <tr> <td>emacs-term</td> <td>0.03</td> <td>13</td> <td>30</td> <td>28</td> <td>49</td> <td>30</td> <td>ok</td> </tr> </tbody> </table> </div> The relationship between the rate that a terminal can sink <code>stdout</code> and its latency is non-obvious. For the matter, the relationship between the rate at which a terminal can sink <code>stdout</code> and how fast it looks is non-obvious. During this test, terminal.app looked very slow. The text that scrolls by jumps a lot, as if the screen is rarely updating. Also, hyper and emacs-term both had problems with this test. Emacs-term can’t really keep up with the output and it takes a few seconds for the display to finish updating after the test is complete (the status bar that shows how many lines have been output appears to be up to date, so it finishes incrementing before the test finishes). Hyper falls further behind and pretty much doesn’t update the screen after a flickering a couple of times. The <code>Hyper Helper</code> process gets pegged at 100% CPU for about two minutes and the terminal is totally unresponsive for that entire time. <p>Alacritty was tested with tmux because alacritty doesn’t support scrolling back up, and the docs indicate that you should use tmux if you want to be able to scroll up. Just to have another reference, terminal.app was also tested with tmux. For most terminals, tmux doesn’t appear to reduce <code>stdout</code> speed, but alacritty and terminal.app are fast enough that they’re actually limited by the speed of tmux.</p> <p>Emacs-eshell is technically not a terminal, but I also tested eshell because it can be used as a terminal alternative for some use cases. Emacs, with both eshell and term, is actually slow enough that I care about the speed at which it can sink <code>stdout</code>. When I’ve used eshell or term in the past, I find that I sometimes have to wait for a few thousand lines of text to scroll by if I run a command with verbose logging to <code>stdout</code> or <code>stderr</code>. Since that happens very rarely, it’s not really a big deal to me unless it’s so slow that I end up waiting half a second or a second when it happens, and no other terminal is slow enough for that to matter.</p> <p>Conversely, I type individual characters often enough that I’ll notice tail latency. Say I type at 120wpm and that results in 600 characters per minute, or 10 characters per second of input. Then I’d expect to see the 99.9% tail (1 in 1000) every 100 seconds!</p> <p>Anyway, the <code>cat</code> “benchmark” that I care about more is whether or not I can <code>^C</code> a process when I’ve accidentally run a command that outputs millions of lines to the screen instead of thousands of lines. For that benchmark, every terminal is fine except for hyper and emacs-eshell, both of which hung for at least ten minutes (I killed each process after ten minutes, rather than waiting for the terminal to catch up).</p> <p>Memory usage at startup is also included in the table for reference because that&#39;s the other measurement I see people benchmark terminals with. While I think that it&#39;s a bit absurd that terminals can use 40MB at startup, even the three year old hand-me-down laptop I&#39;m using has 16GB of RAM, so squeezing that 40MB down to 2MB doesn&#39;t have any appreciable affect on user experience. Heck, even the $300 chromebook we recently got has 16GB of RAM.</p> <h3 id="conclusion">Conclusion</h3> <p>Most terminals have enough latency that the user experience could be improved if the terminals concentrated more on latency and less on other features or other aspects of performance. However, when I search for terminal benchmarks, I find that terminal authors, if they benchmark anything, <a href="https://github.com/jwilm/alacritty/issues/289">benchmark the speed of</a> <a href="https://github.com/jwilm/alacritty/issues/205">sinking stdout</a> or memory usage at startup. This is unfortunate because most “low performance” terminals can already sink <code>stdout</code> many orders of magnitude faster than humans can keep up with, so further optimizing <code>stdout</code> throughput has a relatively small impact on actual user experience for most users. Likewise for reducing memory usage when an idle terminal uses 0.01% of the memory on my old and now quite low-end laptop.</p> <p>If you work on a terminal, perhaps consider relatively more latency and interactivity (e.g., responsiveness to <code>^C</code>) optimization and relatively less throughput and idle memory usage optimization.</p> <p><em>Update: In response to this post, <a href="https://github.com/jwilm/alacritty/issues/673">the author of alacritty explains where alacritty&#39;s latency comes from and describes how alacritty could reduce its latency</a></em></p> <h3 id="appendix-negative-results">Appendix: negative results</h3> <p>Tmux and latency: I tried tmux and various terminals and found that the the differences were within the range of measurement noise.</p> <p>Shells and latency: I tried a number of shells and found that, even in the quickest terminal, the difference between shells was within the range of measurement noise. Powershell was somewhat problematic to test with the setup I was using because it doesn’t handle colors correctly (the first character typed shows up with the color specified by the terminal, but other characters are yellow regardless of setting, <a href="https://github.com/lzybkr/PSReadLine/issues/472">which appears to be an open issue</a>), which confused the image recognition setup I used. <a href="https://www.youtube.com/watch?v=cz5Hczlzvio">Powershell also doesn’t consistently put the cursor where it should be</a> -- it jumps around randomly within a line, which also confused the image recognition setup I used. However, despite its other problems, powershell had comparable performance to other shells.</p> <p>Shells and stdout throughput: As above, the speed difference between different shells was within the range of measurement noise.</p> <p>Single-line vs. multiline text and throughput: Although some text editors bog down with extremely long lines, throughput was similar when I shoved a large file into a terminal whether the file was all one line or was line broken every 80 characters.</p> <p>Head of line blocking / coordinated omission: I ran these tests with input at a rate of 10.3 characters per second. But it turns out this doesn&#39;t matter much and input rates that humans are capapable of and the latencies are quite similar to doing input once every 10.3 seconds. It&#39;s possible to overwhelm a terminal, and hyper is the first to start falling over at high input rates, but the speed necessary to make the tail latency worse is beyond the rate at which any human I know of can type.</p> <h3 id="appendix-experimental-setup">Appendix: experimental setup</h3> <p>All tests were done on a dual core 2.6GHz 13” Mid-2014 Macbook pro. The machine has 16GB of RAM and a 2560x1600 screen. The OS X version was 10.12.5. Some tests were done in Linux (Lubuntu 16.04) to get a comparison between macOS and Linux. 10k keypresses were for each latency measurements.</p> <p>Latency measurements were done with the <code>.</code> key and throughput was done with default <code>base32</code> output, which is all plain ASCII text. George King notes that different kinds of text can change output speed:</p> <blockquote> <p>I’ve noticed that Terminal.app slows dramatically when outputting non-latin unicode ranges. I’m aware of three things that might cause this: having to load different font pages, and having to parse code points outside of the BMP, and wide characters.</p> <p>The first probably boils down to a very complicated mix of lazy loading of font glyphs, font fallback calculations, and caching of the glyph pages or however that works.</p> <p>The second is a bit speculative, but I would bet that Terminal.app uses Cocoa’s UTF16-based NSString, which almost certainly hits a slow path when code points are above the BMP due to surrogate pairs.</p> </blockquote> <p>Terminals were fullscreened before running tests. This affects test results, and resizing the terminal windows can and does significantly change performance (e.g., it’s possible to get hyper to be slower than iterm2 by changing the window size while holding everything else constant). st on macOS was running as an X client under XQuartz. To see if XQuartz is inherently slow, I tried <a href="https://github.com/doy/runes/">runes</a>, another &#34;native&#34; Linux terminal that uses XQuartz; runes had much better tail latency than st and iterm2.</p> <p>The “idle” latency tests were done on a freshly rebooted machine. All terminals were running, but input was only fed to one terminal at a time.</p> <p>The “loaded” latency tests were done with rust compiling in the background, 15s after the compilation started.</p> <p>Terminal bandwidth tests were done by creating a large, pseudo-random, text file with</p> <pre><code>timeout 64 sh -c &#39;cat /dev/urandom | base32 &gt; junk.txt&#39;
</code></pre> <p>and then running</p> <pre><code>timeout 8 sh -c &#39;cat junk.txt | tee junk.term_name&#39;
</code></pre> <p>Terminator and urxvt weren’t tested because they weren’t completely trivial to install on mac and I didn’t want to futz around to make them work. Terminator was easy to build from source, but it hung on startup and didn’t get to a shell prompt. Urxvt installed through brew, but one of its dependencies (also installed through brew) was the wrong version, which prevented it from starting.</p> <p><small> Thanks to Kamal Marhubi, Leah Hanson, Wesley Aptekar-Cassels, David Albert, Vaibhav Sagar, Indradhanush Gupta, Rudi Chen, Laura Lindzey, Ahmad Jarara, George King, Tim Dierks, Nikith Naide, Veit Heller, and Nick Bergson-Shilcock for comments/corrections/discussion. </small></p> </div></div>
        </section>
    </article>
</main>
</body>
</html>
